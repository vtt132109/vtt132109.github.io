<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phân tích Robot Dò Line (V36) - Giao diện Split-View (Chi tiết)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Ngăn cuộn body chính */
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        
        pre code {
            display: block;
            background: #111827; /* bg-gray-900 (darker) */
            color: #d1d5db; /* text-gray-300 */
            padding: 1.5rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem; /* Tăng kích thước font code một chút */
            line-height: 1.7; /* Tăng khoảng cách dòng */
            max-height: 90vh;
        }
        
        /* CSS cho các comment tiếng Việt bên trong code */
        pre code .comment {
            color: #6b7280; /* text-gray-500 */
            font-style: italic;
        }

        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            height: 400px;
            max-height: 50vh;
        }
        
        h2 {
            font-size: 1.875rem;
            font-weight: 700;
            margin-bottom: 1rem;
            margin-top: 2rem;
            border-bottom: 2px solid #3b82f6; /* Nét gạch chân màu xanh */
            padding-bottom: 0.5rem;
            color: #1e3a8a; /* text-blue-900 */
        }
        /* Hiệu ứng cho tiêu đề có thể click */
        h3[onclick] {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            margin-top: 1.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border-radius: 0.375rem;
            padding: 0.5rem;
            margin-left: -0.5rem;
            margin-right: -0.5rem;
            color: #1f2937; /* text-gray-800 */
            border-left: 4px solid transparent;
        }
        h3[onclick]:hover {
            background-color: #f3f4f6; /* bg-gray-100 */
            color: #2563eb; /* text-blue-600 */
            border-left: 4px solid #2563eb;
        }

        p, ul, li {
            margin-bottom: 1rem;
            line-height: 1.75;
            color: #374151; /* text-gray-700 */
        }
        ul {
            list-style-type: disc;
            list-style-position: inside;
            padding-left: 1rem;
        }
        li {
            margin-bottom: 0.5rem;
        }
        
        code:not(pre code) {
            background-color: #e5e7eb; /* bg-gray-200 */
            color: #be185d; /* text-pink-700 */
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-family: 'Consolas', 'Monaco', monospace;
            font-weight: 600;
        }
        
        /* === MỚI: Thêm style cho code inline có thể click === */
        code[onclick] {
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        code[onclick]:hover {
            background-color: #fbcfe8; /* bg-pink-100 */
            color: #9d174d; /* text-pink-800 */
            box-shadow: 0 0 5px #fbcfe8;
        }
        
        /* Class highlight cho code */
        .highlight {
            background-color: #fef08a; /* bg-yellow-300 */
            color: #1f2937; /* text-gray-800 */
            border-radius: 3px;
            padding: 2px 0;
            box-shadow: 0 0 10px #fef08a;
            transition: all 0.3s ease;
        }
    </style>
    <!-- Ghi chú Lập trình:
         Mục tiêu Cập nhật: Làm theo yêu cầu của người dùng, (1) giải thích dài hơn ở pane trái
         và (2) "kéo" giải thích chi tiết vào pane phải.
         
         Thực thi:
         1. (Pane Trái) Mở rộng tất cả các phần `p` và `ul` với nhiều chi tiết "tại sao" hơn.
         2. (Pane Phải) Thêm các comment `// Tiếng Việt...` vào mã nguồn trong `<pre><code>`
            để giải thích các biến, các hàm, và các khối logic.
         3. (Quan trọng) Giữ nguyên các comment `/* --- TARGET: ... --- */`
            để không làm hỏng chức năng `scrollToCode()` của JavaScript.
    -->
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col h-screen antialiased">

    <!-- HEADER -->
    <header class="text-center py-6 bg-white shadow-md z-20 border-b-4 border-blue-600">
        <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Phân tích Robot Dò Line (V36) - Bản Chi Tiết</h1>
        <p class="text-md text-gray-600 mt-1">Giao diện Phân tích Code Tương tác (Split-Screen)</p>
    </header>

    <!-- MAIN CONTENT (Split Screen) -->
    <main class="flex-1 flex flex-col md:flex-row overflow-hidden">
        
        <!-- === PANE TRÁI: BÁO CÁO PHÂN TÍCH === -->
        <div id="panel-report" class="md:w-1/2 h-full overflow-y-auto p-6 md:p-10 bg-white shadow-lg z-10 border-r border-gray-200">
            <section id="bao-cao">
                <h1 class="text-3xl font-bold mb-6 text-gray-900">Báo cáo Phân tích Code Chi tiết: Xe Dò Line (V36)</h1>
                <p>Tài liệu này giải thích chi tiết toàn bộ mã nguồn của file <code>LineFollower_V36.ino</code>. Phiên bản này đã được cập nhật với các giải thích sâu hơn ở cả hai bên.</p>
                <p>Bấm vào các tiêu đề <code>h3</code> (ví dụ: "Mục tiêu của Dự án") bên dưới để tự động cuộn đến và <span class="bg-yellow-200 px-1 rounded">highlight</span> phần code tương ứng ở bên phải.</p>

                <h2 onclick="scrollToCode('MỤC TIÊU CỦA DỰ ÁN')" class="cursor-pointer hover:text-blue-600">PHẦN 1: TỔNG QUAN VÀ CẤU TRÚC</h2>

                <h3 onclick="scrollToCode('MỤC TIÊU CỦA DỰ ÁN')">1.1. Mục tiêu của Dự án</h3>
                <p>Mã nguồn này điều khiển một robot 4 bánh (4WD) sử dụng shield <code onclick="scrollToCode('#include &lt;AFMotor.h&gt;')" title="Click để xem code">AFMotor</code>, vốn chứa 2 chip điều khiển cầu H L293D. Mỗi chip điều khiển 2 động cơ, do đó robot 4WD này sử dụng cả 4 cổng motor (M1, M2, M3, M4).</p>
                <p>Robot có hai chức năng chính hoạt động song song:</p>
                <ul>
                    <li><strong>Dò line (Line Following):</strong> Sử dụng 4 cảm biến hồng ngoại (S1-S4) để tự động đi theo một vạch đen trên nền trắng. Trái tim của chức năng này là một bộ điều khiển <strong onclick="scrollToCode('Biến toàn cục cho PID')" class="cursor-pointer text-blue-600">PID</strong>.</li>
                    <li><strong>Tránh vật cản (Obstacle Avoidance):</strong> Sử dụng một cảm biến siêu âm (SRF-04/HC-SR04) được gắn trên một động cơ servo. Khi phát hiện vật cản trong tầm 15cm, robot sẽ ưu tiên dừng dò line. Nó sẽ quay servo để <strong>quét không gian</strong> bên trái và bên phải, sau đó quyết định rẽ vào hướng thoáng hơn để thực hiện một động tác rẽ chữ U (U-turn) nhằm vòng qua vật cản.</li>
                </ul>

                <h3 onclick="scrollToCode('LOGIC NỔI BẬT')">1.2. Các Logic Nổi bật (Phiên bản V36)</h3>
                <p>Đây là phiên bản đã trải qua nhiều cải tiến, tích hợp các logic xử lý tình huống rất phức tạp và hiệu quả:</p>
                <ul>
                    <li><strong>PID Thích ứng (Adaptive PID):</strong> Đây là logic quan trọng nhất trong <code onclick="scrollToCode('CASE 6')" title="Click để xem code">CASE 6</code>. Robot theo dõi "độ ổn định" (<code onclick="scrollToCode('int stabilityCounter = 0;')" title="Click để xem code">stabilityCounter</code>).
                        <ul>
                            <li>Khi robot chạy thẳng và ổn định (<code onclick="scrollToCode('if (stabilityCounter > 20)')" title="Click để xem code">stabilityCounter > 20</code>), nó giả định đang ở đoạn đường thẳng. Nó sẽ <strong>tăng tốc</strong> (lên 240) và <strong>giảm Kp</strong> (xuống 40.0) để chạy mượt, nhanh và ít bị rung.</li>
                            <li>Khi robot mất ổn định (vào cua, <code onclick="scrollToCode('int stabilityCounter = 0;')" title="Click để xem code">stabilityCounter = 0</code>), nó sẽ <strong>giảm tốc</strong> (xuống 210) và <strong>tăng Kp</strong> (lên 100.0) để tăng độ nhạy, giúp robot bám cua gắt hơn.</li>
                        </ul>
                    </li>
                    <li><strong>Grace Period (10 giây đầu):</strong> Trong 10 giây đầu tiên (<code onclick="scrollToCode('#define INITIAL_GRACE_PERIOD 10000')" title="Click để xem code">INITIAL_GRACE_PERIOD</code>), robot <strong>bắt buộc</strong> <code onclick="scrollToCode('s1 = false; // Tắt S1')" title="Click để xem code">s1 = false</code> và <code onclick="scrollToCode('s4 = false; // Tắt S4')" title="Click để xem code">s4 = false</code>. Điều này vô hiệu hóa tất cả các logic rẽ (ngã tư, cua gắt <code onclick="scrollToCode('CASE 3A')" title="Click để xem code">1110</code>, <code onclick="scrollToCode('CASE 3B')" title="Click để xem code">0111</code>, <code onclick="scrollToCode('CASE 1.5')" title="Click để xem code">1001</code>...). Robot chỉ chạy PID đơn thuần bằng 2 cảm biến giữa (S2, S3).
                        <br><strong>Lý do:</strong> Ngăn robot rẽ nhầm ngay tại vạch xuất phát nếu vạch này giao với các đường khác.
                    </li>
                    <li><strong>Xử lý Ngã rẽ Thông minh (V34 Logic):</strong> Hàm <code onclick="scrollToCode('void performTurn()')" title="Click để xem code">performTurn()</code> (thực hiện rẽ) được thiết kế để không bị "lừa" ở ngã ba tam giác (Y-split).
                        <ul>
                            <li>Khi rẽ phải, nó không tìm <code>0011</code>. Nó tìm <code onclick="scrollToCode('if (s3 && !s4)')" title="Click để xem code">xx10</code> (S3 thấy line, S4 *không* thấy).</li>
                            <li>Khi rẽ trái, nó không tìm <code>1100</code>. Nó tìm <code onclick="scrollToCode('if (s2 && !s1)')" title="Click để xem code">01xx</code> (S2 thấy line, S1 *không* thấy).</li>
                        </ul>
                        Điều này đảm bảo robot chỉ dừng xoay khi nó đã đi vào *trung tâm* của line mới, chứ không phải mép của line cũ.
                    </li>
                    <li><strong>Xử lý Mất Line Thông minh (V30 Logic):</strong> Khi mất line (<code onclick="scrollToCode('CASE 5')" title="Click để xem code">0000</code>), robot không dừng lại. Nó sẽ cố gắng tìm line trong 500ms (dựa vào <code onclick="scrollToCode('float previous_error = 0;')" title="Click để xem code">previous_error</code> để đoán hướng rẽ). Nếu vẫn không thấy, nó sẽ chuyển sang chế độ "xoay tròn tại chỗ" để tích cực tìm kiếm thay vì "bỏ cuộc".</li>
                    <li><strong>Xử lý Trường hợp Đặc biệt (V35 Logic):</strong> Thêm một trường hợp ưu tiên <code onclick="scrollToCode('CASE 1.5')" title="Click để xem code">1001</code> (S1 và S4 cùng thấy line, thường xảy ra ở ngã ba hẹp hoặc giao điểm chữ X), và ưu tiên rẽ trái. Đây là <code onclick="scrollToCode('CASE 1.5')" title="Click để xem code">CASE 1.5</code>, có độ ưu tiên cao nhất.</li>
                </ul>

                <h2 onclick="scrollToCode('PHÂN TÍCH CÁC KHỐI CODE')" class="cursor-pointer hover:text-blue-600">PHẦN 2: PHÂN TÍCH CÁC KHỐI CODE</h2>

                <h3 onclick="scrollToCode('Thư viện và Cấu hình')">2.1. Thư viện và Cấu hình (Defines & Globals)</h3>
                <p>Phần này định nghĩa các "hằng số" và "biến toàn cục" quyết định hành vi của robot.</p>
                <ul>
                    <li><strong>Thư viện:</strong> <code onclick="scrollToCode('#include &lt;AFMotor.h&gt;')" title="Click để xem code">&lt;AFMotor.h&gt;</code> (điều khiển shield motor Adafruit), <code onclick="scrollToCode('#include &lt;Servo.h&gt;')" title="Click để xem code">&lt;Servo.h&gt;</code> (điều khiển servo siêu âm).</li>
                    <li><strong>Hằng số Cấu hình:</strong>
                        <ul>
                            <li><code onclick="scrollToCode('#define MIN_PWM 80')" title="Click để xem code">MIN_PWM 80</code>: Ngưỡng PWM tối thiểu. Bất kỳ tốc độ nào dưới 80 sẽ bị coi là 0. <strong>Lý do:</strong> Động cơ DC cần một mức điện áp tối thiểu để thắng lực ma sát và bắt đầu quay. Đặt giá trị này quá thấp sẽ khiến robot "ì" khi PID yêu cầu chỉnh nhẹ.</li>
                            <li><code onclick="scrollToCode('const float LEFT_OFFSET = 1.0;')" title="Click để xem code">LEFT_OFFSET</code>, <code onclick="scrollToCode('const float RIGHT_OFFSET = 0.9;')" title="Click để xem code">RIGHT_OFFSET</code>: Hệ số hiệu chỉnh. <strong>Lý do:</strong> Hầu như không bao giờ có 2 động cơ nào chạy nhanh y hệt nhau dù cùng 1 mức PWM. Các hằng số này (ví dụ: <code onclick="scrollToCode('const float RIGHT_OFFSET = 0.9;')" title="Click để xem code">RIGHT_OFFSET = 0.9</code>) làm cho bên phải chạy chậm lại 10% để robot đi thẳng.</li>
                            <li><code onclick="scrollToCode('#define LOST_LINE_TIMEOUT 500')" title="Click để xem code">LOST_LINE_TIMEOUT 500</code>: 500ms là thời gian robot cố gắng "dò dẫm" theo hướng cũ khi mất line (<code onclick="scrollToCode('CASE 5')" title="Click để xem code">0000</code>) trước khi quyết định xoay tròn.</li>
                            <li><code onclick="scrollToCode('#define INITIAL_GRACE_PERIOD 10000')" title="Click để xem code">INITIAL_GRACE_PERIOD 10000</code>: 10 giây ân xá.</li>
                            <li><code onclick="scrollToCode('#define OBSTACLE_DISTANCE 15')" title="Click để xem code">OBSTACLE_DISTANCE 15</code>: Khoảng cách (cm) kích hoạt tránh vật cản.</li>
                        </ul>
                    </li>
                    <li><strong>Biến Toàn cục (Quan trọng):</strong>
                        <ul>
                            <li><code onclick="scrollToCode('int SENSOR_MIN_CALI = 1023;')" title="Click để xem code">SENSOR_MIN_CALI</code>, <code onclick="scrollToCode('int SENSOR_MAX_CALI = 0;')" title="Click để xem code">SENSOR_MAX_CALI</code>: Lưu giá trị analog đọc được trên nền trắng nhất (MIN) và line đen nhất (MAX). Dùng để chuẩn hóa (normalize) giá trị cảm biến về thang 0.0 -> 1.0.</li>
                            <li><code onclick="scrollToCode('int threshold_for_turn = 500;')" title="Click để xem code">threshold_for_turn</code>: Ngưỡng (ví dụ: 500) để quyết định <code>true</code> (đen) hay <code>false</code> (trắng) cho các cảm biến S1-S4.</li>
                            <li><strong>Biến PID:</strong> <code onclick="scrollToCode('Biến toàn cục cho PID')" title="Click để xem code">error</code> (sai số hiện tại), <code onclick="scrollToCode('Biến toàn cục cho PID')" title="Click để xem code">previous_error</code> (sai số trước đó, dùng cho D), <code onclick="scrollToCode('Biến toàn cục cho PID')" title="Click để xem code">I</code> (tích phân, dùng cho I), <code onclick="scrollToCode('Biến toàn cục cho PID')" title="Click để xem code">pre_pos</code> (vị trí trước đó, dùng khi mất line).</li>
                            <li><strong>Biến Trạng thái (State):</strong> <code onclick="scrollToCode('bool isTurning = false;')" title="Click để xem code">isTurning</code>, <code onclick="scrollToCode('bool isAvoidingObstacle = false;')" title="Click để xem code">isAvoidingObstacle</code>. Đây là các "cờ" (flags) để báo cho <code>loop()</code> biết robot đang bận, không được chạy <code>linetracingMode()</code>.</li>
                            <li><code onclick="scrollToCode('unsigned long programStartTime = 0;')" title="Click để xem code">programStartTime</code>: Lưu thời điểm <code>millis()</code> lúc <code>setup()</code> để tính "Grace Period".</li>
                        </ul>
                    </li>
                </ul>

                <h3 onclick="scrollToCode('CÁC HÀM ĐIỀU KHIỂN ĐỘNG CƠ')">2.2. Các hàm Điều khiển Động cơ</h3>
                <p>Các hàm <code onclick="scrollToCode('void setLeftMotors(int speed)')" title="Click để xem code">setLeftMotors(int speed)</code> và <code onclick="scrollToCode('void setRightMotors(int speed)')" title="Click để xem code">setRightMotors(int speed)</code> không chỉ đơn giản là đặt tốc độ. Chúng là các hàm "thông minh" thực hiện 3 logic quan trọng:</p>
                <ol>
                    <li><strong>Áp dụng Offset:</strong> Nhân tốc độ với <code onclick="scrollToCode('const float LEFT_OFFSET = 1.0;')" title="Click để xem code">LEFT_OFFSET</code> hoặc <code onclick="scrollToCode('const float RIGHT_OFFSET = 0.9;')" title="Click để xem code">RIGHT_OFFSET</code> để cân bằng.</li>
                    <li><strong>Kiểm tra <code onclick="scrollToCode('#define MIN_PWM 80')" title="Click để xem code">MIN_PWM</code>:</strong> Nếu tốc độ yêu cầu (sau khi offset) nằm trong khoảng <code>-MIN_PWM</code> và <code>+MIN_PWM</code> (nhưng không phải 0), hàm sẽ ép tốc độ về 0.</li>
                    <li><strong>Quyết định Hướng:</strong> Dựa trên <code>speed</code> cuối cùng là âm, dương, hay bằng 0, hàm sẽ gọi <code onclick="scrollToCode('motorLeftFront.run(FORWARD);')" title="Click để xem code">FORWARD</code>, <code onclick="scrollToCode('motorLeftFront.run(BACKWARD);')" title="Click để xem code">BACKWARD</code>, hoặc <code onclick="scrollToCode('motorLeftFront.run(RELEASE);')" title="Click để xem code">RELEASE</code> (thả nổi, tiết kiệm năng lượng và cho phép robot trôi tự nhiên, khác với <code>BRAKE</code>).</li>
                </ol>

                <h3 onclick="scrollToCode('CÁC HÀM CẢM BIẾN VÀ LOGIC')">2.3. Các hàm Cảm biến và Logic Phụ</h3>
                <ul>
                    <li onclick="scrollToCode('manual_calibration()')"><code>manual_calibration()</code>: Chạy 5 giây trong <code>setup()</code>. Yêu cầu người dùng lia robot qua vạch đen và nền trắng. Nó liên tục cập nhật <code>SENSOR_MIN_CALI</code> và <code>SENSOR_MAX_CALI</code>. <strong>Lý do:</strong> Giúp robot thích ứng với mọi điều kiện ánh sáng, mọi loại nền (trắng/vàng) và mọi loại vạch (đen/xanh).</li>
                    <li onclick="scrollToCode('checkUltrasonicDistance()')"><code>checkUltrasonicDistance()</code>: Phát một xung 10 micro giây ở chân <code>TRIG</code>, sau đó dùng <code>pulseIn()</code> để đo thời gian (micro giây) mà chân <code>ECHO</code> ở mức HIGH. Nó chuyển thời gian này sang cm. Trả về <code>999.0</code> nếu <code>pulseIn</code> bị timeout (quá 50ms, tức là không thấy vật cản).</li>
                    <li onclick="scrollToCode('scanSurroundings()')"><code>scanSurroundings()</code>: Được gọi khi gặp vật cản. Servo quét sang trái (góc 160), đo <code>distLeft</code>. Quét sang phải (góc 20), đo <code>distRight</code>. Sau đó quay về giữa (90). Trả về <code>true</code> (rẽ phải) nếu bên phải thoáng hơn, ngược lại trả về <code>false</code> (rẽ trái).</li>
                    <li onclick="scrollToCode('performAvoidance()')"><code>performAvoidance()</code>: Một "Máy Trạng Thái" (State Machine) phức tạp. Dựa vào biến <code>avoidState</code> (1, 11, 2, 22...), nó thực hiện một chuỗi 4 bước rẽ chữ U để vòng qua vật cản. Nó dùng <code>millis()</code> để định thời gian cho mỗi bước (ví dụ: <code>TURN_DURATION</code>).</li>
                    <li onclick="scrollToCode('performTurn()')"><code>performTurn()</code>: Hàm này được gọi liên tục khi <code onclick="scrollToCode('bool isTurning = false;')" title="Click để xem code">isTurning = true</code>. Nó rất thông minh:
                        <ul>
                            <li>Nếu đang <code onclick="scrollToCode('bool turningRight = false;')" title="Click để xem code">turningRight = true</code>, nó tiếp tục xoay phải VÀ liên tục đọc cảm biến, chờ cho đến khi gặp trạng thái <code onclick="scrollToCode('if (s3 && !s4)')" title="Click để xem code">s3 && !s4</code> (thấy S3 nhưng không thấy S4).</li>
                            <li>Tương tự khi rẽ trái, nó chờ <code onclick="scrollToCode('if (s2 && !s1)')" title="Click để xem code">s2 && !s1</code>.</li>
                        </ul>
                        <p>Logic này đảm bảo robot không dừng xoay sớm khi gặp ngã ba (ví dụ, trạng thái <code>0011</code> khi rẽ phải).</p>
                    </li>
                </ul>
                
                <hr class="my-8 border-t-2 border-gray-200">

                <section id="visualization">
                    <h2 class="text-3xl font-bold mb-6 text-gray-900">Trực quan hóa Logic Dò Line</h2>
                    <p class="mb-6">Hàm <code>linetracingMode()</code> là trái tim của robot. Nó là một chuỗi các lệnh <code>if-else if</code> được sắp xếp theo <strong>thứ tự ưu tiên</strong>. Biểu đồ dưới đây tóm tắt các nhóm logic chính (không bao gồm "Grace Period" vì nó chỉ sửa đổi các logic này).</p>
                    
                    <div class="chart-container">
                        <canvas id="logicCasesChart"></canvas>
                    </div>
                    <p class="text-center text-sm text-gray-600 mt-2">Biểu đồ thể hiện các nhóm logic trong hàm <code>linetracingMode()</code></p>
                </section>
                
                <hr class="my-8 border-t-2 border-gray-200">

                <h2 onclick="scrollToCode('linetracingMode()')" class="cursor-pointer hover:text-blue-600">PHẦN 3: HÀM `linetracingMode()` (TRÁI TIM CỦA ROBOT)</h2>
                <p>Đây là hàm phức tạp nhất, là bộ não xử lý việc dò line. Nó chỉ được gọi khi robot rảnh (<code onclick="scrollToCode('bool isTurning = false;')" title="Click để xem code">!isTurning</code> và <code onclick="scrollToCode('bool isAvoidingObstacle = false;')" title="Click để xem code">!isAvoidingObstacle</code>). Logic của nó chạy theo thứ tự ưu tiên từ trên xuống dưới:</p>
                <ol class="list-decimal list-inside space-y-2">
                    <li><strong>Kiểm tra <code onclick="scrollToCode('bool isTurning = false;')" title="Click để xem code">isTurning</code>:</strong> Nếu đang rẽ (<code onclick="scrollToCode('if (isTurning) { performTurn(); return; }')" title="Click để xem code">isTurning=true</code>), gọi <code onclick="scrollToCode('void performTurn()')" title="Click để xem code">performTurn()</code> và <code>return</code> ngay. Đây là ưu tiên 0.</li>
                    <li><strong>Đọc và Chuẩn hóa Cảm biến:</strong> Đọc giá trị 0-1023, chuẩn hóa về 0.0-1.0 (<code onclick="scrollToCode('float eachError[4];')" title="Click để xem code">eachError[]</code>), sau đó chuyển sang <code>bool</code> (true/false) dựa trên <code onclick="scrollToCode('float see_line_threshold = 0.7;')" title="Click để xem code">see_line_threshold = 0.7</code>.</li>
                    <li onclick="scrollToCode('Logic &quot;Grace Period&quot;')"><strong>Logic "Grace Period" (V35):</strong> Kiểm tra <code onclick="scrollToCode('bool isGracePeriod = (currentTime - programStartTime < INITIAL_GRACE_PERIOD);')" title="Click để xem code">millis() - programStartTime</code>. Nếu còn trong 10 giây đầu, nó <strong>ép</strong> <code onclick="scrollToCode('s1 = false; // Tắt S1')" title="Click để xem code">s1 = false</code> và <code onclick="scrollToCode('s4 = false; // Tắt S4')" title="Click để xem code">s4 = false</code>, bất kể giá trị đọc được là gì.</li>
                    <li><strong>Hệ thống Phân loại (Các CASE - Sắp xếp theo thứ tự ưu tiên):</strong>
                        <ul>
                            <li onclick="scrollToCode('CASE 1.5')"><code>CASE 1.5 (1001)</code>: (Sau 10s) <strong>Ưu tiên cao nhất.</strong> Thấy 2 cảm biến ngoài. Thường là ngã ba hẹp. Quyết định rẽ TRÁI.</li>
                            <li onclick="scrollToCode('CASE 2')"><code>CASE 2 (1111)</code>: (Sau 10s) Ngã tư. Kích hoạt <code>isTurning = true</code>, <code>turningRight = true</code> để bắt đầu <code>performTurn()</code> rẽ phải.</li>
                            <li onclick="scrollToCode('CASE 3A')"><code>CASE 3A (1110) / 3B (0111)</code>: (Sau 10s) Cua gắt/Ngã rẽ. Kích hoạt <code>isTurning = true</code> (trái/phải).</li>
                            <li onclick="scrollToCode('CASE 4A')"><code>CASE 4A (0100) / 4B (0010)</code>: Line hơi lệch vào 1 trong 2 cảm biến giữa. Chỉnh nhẹ (ví dụ: -100/180).</li>
                            <li onclick="scrollToCode('CASE 4C')"><code>CASE 4C (1000) / 4D (0001)</code>: (Sau 10s) Line lệch hẳn ra 1 trong 2 cảm biến ngoài. Đây là lỗi nghiêm trọng. Robot <strong>xoay tại chỗ</strong> (ví dụ: -200/200) để tìm lại line ngay lập tức.</li>
                            <li onclick="scrollToCode('CASE 5')"><code>CASE 5 (0000)</code>: Mất line. Bắt đầu đếm <code>lostLineStartTime</code>. Trong 500ms đầu, chạy theo <code>previous_error</code>. Sau 500ms, xoay tròn tại chỗ.</li>
                            <li onclick="scrollToCode('CASE 6')"><code>CASE 6 (Else)</code>: <strong>Dò line PID (Trường hợp bình thường).</strong> Đây là trường hợp phổ biến nhất (ví dụ: <code>0110</code>, <code>0010</code>, <code>0100</code>...).
                                <ul>
                                    <li><strong>Tính <code onclick="scrollToCode('float pos_pid = 0.0;')" title="Click để xem code">pos_pid</code>:</strong> Tính vị trí line (0-3000) dựa trên trọng số của 4 cảm biến (hoặc 2 nếu trong Grace Period).</li>
                                    <li><strong>PID Thích ứng Kp:</strong> Kiểm tra <code onclick="scrollToCode('int stabilityCounter = 0;')" title="Click để xem code">stabilityCounter</code>. Nếu <code>> 20</code>, dùng <code>Kp = 40.0</code> (thấp) và <code>initSpeed = 240</code> (cao). Ngược lại, dùng <code>Kp = 100.0</code> (cao) và <code>initSpeed = 210</code> (thấp).</li>
                                    <li><strong>Tính PID:</strong> Tính <code onclick="scrollToCode('PID_value = (current_Kp * P)')" title="Click để xem code">PID_value</code> dựa trên <code>Kp, Ki, Kd</code>.</li>
                                    <li><strong>Ra lệnh:</strong> <code onclick="scrollToCode('int left_motor_speed = constrain(current_initSpeed + PID_value, -255, 255);')" title="Click để xem code">left_speed = initSpeed + PID_value</code>, <code onclick="scrollToCode('int right_motor_speed = constrain(current_initSpeed - PID_value, -255, 255);')" title="Click để xem code">right_speed = initSpeed - PID_value</code>.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ol>

                <h2 onclick="scrollToCode('HÀM SETUP VÀ LOOP CHÍNH')" class="cursor-pointer hover:text-blue-600">PHẦN 4: VÒNG LẶP CHÍNH (`setup()` và `loop()`)</h2>
                <ul>
                    <li onclick="scrollToCode('void setup()')"><code>setup()</code>:
                        <ol class="list-decimal list-inside ml-4">
                            <li>Khởi tạo <code>Serial</code>, <code>pinMode</code>, <code>Servo</code>.</li>
                            <li><strong>Chạy <code onclick="scrollToCode('manual_calibration();')" title="Click để xem code">manual_calibration()</code></strong>: Đây là bước quan trọng nhất, quyết định mọi ngưỡng cảm biến.</li>
                            <li><strong>Gán <code onclick="scrollToCode('programStartTime = millis();')" title="Click để xem code">programStartTime = millis()</code></strong>: Bắt đầu đếm 10 giây "Grace Period".</li>
                            <li>Gán <code onclick="scrollToCode('robotState = 1;')" title="Click để xem code">robotState = 1</code> (Tự động BẬT).</li>
                        </ol>
                    </li>
                    <li onclick="scrollToCode('void loop()')"><code>loop()</code>: Đây là "bộ não" quyết định thứ tự ưu tiên của toàn bộ robot.
                        <ol class="list-decimal list-inside ml-4">
                            <li><strong>Ưu tiên 1: Đang tránh vật cản?</strong>
                                <br><code onclick="scrollToCode('if (isAvoidingObstacle) {')" title="Click để xem code">if (isAvoidingObstacle)</code>: Nếu <code>true</code>, chỉ chạy <code onclick="scrollToCode('void performAvoidance()')" title="Click để xem code">performAvoidance()</code> và <code>return</code>. Không làm gì khác.</li>
                            <li><strong>Ưu tiên 2: Robot đang TẮT?</strong>
                                <br><code onclick="scrollToCode('if (robotState == 0) { stopMotorsAndLed(); return; }')" title="Click để xem code">if (robotState == 0)</code>: Nếu <code>true</code>, dừng robot và <code>return</code>.</li>
                            <li><strong>Ưu tiên 3: Có vật cản MỚI?</strong>
                                <br><code onclick="scrollToCode('if (currentDistance < OBSTACLE_DISTANCE) {')" title="Click để xem code">if (currentDistance < OBSTACLE_DISTANCE)</code>: Nếu phát hiện vật cản VÀ robot rảnh (<code onclick="scrollToCode('if (!isAvoidingObstacle && !isTurning) {')" title="Click để xem code">!isTurning</code>), dừng mọi thứ, gọi <code onclick="scrollToCode('bool scanSurroundings()')" title="Click để xem code">scanSurroundings()</code>, và đặt <code onclick="scrollToCode('isAvoidingObstacle = true;')" title="Click để xem code">isAvoidingObstacle = true</code>.</li>
                            <li><strong>Ưu tiên 4: Dò line.</strong>
                                <br><code onclick="scrollToCode('else {')" title="Click để xem code">else { linetracingMode(); }</code>: Nếu không có gì ở trên, chạy <code onclick="scrollToCode('linetracingMode();')" title="Click để xem code">linetracingMode()</code> bình thường.</li>
                        </ol>
                    </li>
                </ul>
            </section>
        </div>
        
        <!-- === PANE PHẢI: MÃ NGUỒN (VỚI COMMENT CHI TIẾT) === -->
        <div id="panel-code" class="md:w-1/2 h-full overflow-y-auto p-6 md:p-10 bg-gray-900 text-gray-300">
            <div class="relative">
                <button onclick="copyCode()" id="copy-btn" class="absolute top-4 right-4 bg-gray-700 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200 z-10">
                    Sao chép Mã
                </button>
<pre><code id="code-content">/*
 * =================================================================================
 * TÊN DỰ ÁN: XE DÒ LINE SIÊU ÂM (V36 - ĐỌN GIẢN COMMENT)
 * /* --- TARGET: MỤC TIÊU CỦA DỰ ÁN --- */
 * MÔ TẢ:
 * Dựa trên V35.
 *
 * /* --- TARGET: LOGIC NỔI BẬT --- */
 * --- LOGIC NỔI BẬT (TỪ V35) ---
 * 1. MỤC TIÊU:
 * a. Thêm chế độ "Grace Period" (Ân xá): 10 giây đầu tiên chỉ dò line
 * bằng 2 cảm biến giữa (S2, S3), bỏ qua mọi trường hợp rẽ.
 * b. Thêm trường hợp đặc biệt `1001` (S1 và S4 cùng thấy line) thì
 * ưu tiên rẽ TRÁI.
 *
 * 2. LOGIC "GRACE PERIOD":
 * - 10 giây đầu (`INITIAL_GRACE_PERIOD`).
 * - Tự động gán `s1 = false` và `s4 = false`. (Vô hiệu hóa các CASE rẽ).
 * - `CASE 6 (PID)` CHỈ tính toán `pos_pid` dựa trên S2 và S3.
 *
 * 3. CASE 1.5 (1001):
 * - Sau 10 giây, nếu gặp `1001`, robot sẽ thực hiện cú xoay TRÁI mạnh.
 *
 * 4. LOGIC KHÁC (TỪ V34):
 * - `performTurn()` thông minh (kiểm tra `xx10` và `01xx`).
 * - Quét Servo siêu âm tránh vật cản.
 *
 * --- KẾT NỐI PHẦN CỨNG ---
 * (Giữ nguyên)
 * =================================================================================
 */

/* --- TARGET: Thư viện và Cấu hình --- */
<span class="comment">// --- THƯ VIỆN ---</span>
#include &lt;AFMotor.h&gt; <span class="comment">// Thư viện cho shield motor Adafruit (L293D)</span>
#include &lt;Servo.h&gt;   <span class="comment">// Thư viện cho động cơ servo (để quét siêu âm)</span>

<span class="comment">// --- CẤU HÌNH VÀ PIN ---</span>
const bool DEBUG_PRINT = 1; <span class="comment">// Bật/tắt Serial.print. (1 = Bật)</span>

<span class="comment">// --- CẤU HÌNH MOTOR ---</span>
#define MIN_PWM 80 <span class="comment">// Ngưỡng PWM tối thiểu để động cơ bắt đầu quay</span>
const float LEFT_OFFSET = 1.0; <span class="comment">// Hệ số hiệu chỉnh tốc độ motor trái</span>
const float RIGHT_OFFSET = 0.9; <span class="comment">// Hệ số hiệu chỉnh motor phải (0.9 = chậm hơn 10%)</span>

<span class="comment">// --- CẤU HÌNH KHÁC ---</span>
#define LOST_LINE_TIMEOUT 500 <span class="comment">// (ms) Thời gian cố tìm line trước khi xoay (CASE 5)</span>

<span class="comment">// Thời gian ân xá: 10 giây đầu chỉ chạy PID 2 cảm biến</span>
#define INITIAL_GRACE_PERIOD 10000 <span class="comment">// 10 giây (10000 ms)</span>

<span class="comment">// Cấu hình quét Servo siêu âm</span>
#define SCAN_LEFT 160     <span class="comment">// Góc quét bên trái</span>
#define SCAN_CENTER 90    <span class="comment">// Góc ở giữa</span>
#define SCAN_RIGHT 20     <span class="comment">// Góc quét bên phải</span>
#define SCAN_DELAY 300    <span class="comment">// (ms) Thời gian chờ servo quay đến góc</span>

<span class="comment">// Cấu hình tránh vật cản (State Machine)</span>
#define OBSTACLE_DISTANCE 15 <span class="comment">// (cm) Khoảng cách kích hoạt</span>
#define TURN_SPEED 180       <span class="comment">// Tốc độ khi xoay 90 độ</span>
#define AVOID_SPEED 150      <span class="comment">// Tốc độ khi đi thẳng vòng qua</span>
#define SEARCH_SPEED 130     <span class="comment">// Tốc độ khi đi thẳng tìm line</span>
#define TURN_DURATION 600    <span class="comment">// (ms) Thời gian để xoay 90 độ</span>
#define STRAIGHT_DURATION 1000 <span class="comment">// (ms) Thời gian đi thẳng vòng qua</span>
#define SEARCH_TIMEOUT 3000  <span class="comment">// (ms) Thời gian tối đa tìm line trước khi bỏ cuộc</span>


<span class="comment">// ================================================================================
// Biến lưu giá trị hiệu chỉnh (calibration)
// Sẽ được gán giá trị trong hàm manual_calibration()</span>
int SENSOR_MIN_CALI = 1023; <span class="comment">// Giá trị analog thấp nhất (nền TRẮNG)</span>
int SENSOR_MAX_CALI = 0;    <span class="comment">// Giá trị analog cao nhất (line ĐEN)</span>
int threshold_for_turn = 500; <span class="comment">// Ngưỡng quyết định (Đen/Trắng) cho các CASE rẽ</span>
<span class="comment">// ================================================================================</span>

<span class="comment">// Cảm biến siêu âm</span>
#define ULTRA_TRIG_PIN A0
#define ULTRA_ECHO_PIN A1

<span class="comment">// Servo (Giờ dùng cho siêu âm)</span>
#define SERVO_PIN 9 <span class="comment">// Phải là pin PWM (~)</span>
Servo myServo;

<span class="comment">// Cảm biến dò line (S1-S4 từ trái qua phải)</span>
uint8_t sens[] = {A2, A3, A4, A5}; <span class="comment">// S1, S2, S3, S4</span>

<span class="comment">// Biến toàn cục cho PID</span>
const float Ki = 0.01; <span class="comment">// Hệ số Tích phân (Integral) - Giảm sai số tích lũy</span>
const float Kd = 10.0; <span class="comment">// Hệ số Vi phân (Derivative) - Giảm vọt lố (overshoot)</span>
float error = 0, P = 0, I = 0, D = 0, PID_value = 0;
float previous_error = 0; <span class="comment">// Lưu sai số của vòng lặp trước (cho Kd)</span>
float previous_I = 0;     <span class="comment">// Lưu giá trị I của vòng lặp trước</span>
float pre_pos = 1500.0;   <span class="comment">// Lưu vị trí line cuối cùng (0-3000), dùng khi mất line</span>

<span class="comment">// Biến trạng thái (State Flags)</span>
int robotState = 0; <span class="comment">// 0 = TẮT, 1 = BẬT (Tự động BẬT trong setup)</span>
int stabilityCounter = 0; <span class="comment">// Đếm số vòng lặp robot chạy ổn định (cho PID Thích ứng)</span>
unsigned long lostLineStartTime = 0; <span class="comment">// (ms) Thời điểm bắt đầu mất line (CASE 5)</span>
bool isTurning = false; <span class="comment">// Cờ: Robot đang bận rẽ (CASE 2, 3)</span>
unsigned long turnStartTime = 0; <span class="comment">// (ms) Thời điểm bắt đầu rẽ</span>
bool turningRight = false; <span class="comment">// Robot đang rẽ phải hay trái?</span>
int currentTurnSpeed = 0; <span class="comment">// Tốc độ rẽ hiện tại</span>
unsigned long currentMaxTurnTime = 0; <span class="comment">// Thời gian rẽ tối đa (timeout)</span>

<span class="comment">// Thời điểm bắt đầu chương trình (cho Grace Period)</span>
unsigned long programStartTime = 0;

<span class="comment">// Trạng thái tránh vật cản (State Machine)</span>
bool isAvoidingObstacle = false; <span class="comment">// Cờ: Robot đang bận tránh vật cản</span>
int avoidState = 0; <span class="comment">// Trạng thái con (1, 11, 2, 22...)</span>
unsigned long avoidStartTime = 0; <span class="comment">// (ms) Thời điểm bắt đầu một bước tránh</span>
bool avoidTurnRight = false; <span class="comment">// Quyết định rẽ phải hay trái để tránh</span>

<span class="comment">// --- KHỞI TẠO ĐỐI TƯỢNG ĐỘNG CƠ (4WD) ---</span>
AF_DCMotor motorLeftFront(1);   <span class="comment">// M1</span>
AF_DCMotor motorLeftRear(2);    <span class="comment">// M2</span>
AF_DCMotor motorRightFront(3);  <span class="comment">// M3</span>
AF_DCMotor motorRightRear(4);   <span class="comment">// M4</span>

/*
 * =================================================================================
 * /* --- TARGET: CÁC HÀM ĐIỀU KHIỂN ĐỘNG CƠ --- */
 * CÁC HÀM ĐIỀU KHIỂN ĐỘNG CƠ
 * =================================================================================
 */

<span class="comment">// Hàm điều khiển 2 động cơ TRÁI (Áp dụng offset và min_pwm)</span>
void setLeftMotors(int speed) {
  <span class="comment">// 1. Áp dụng offset và giới hạn tốc độ trong khoảng -255 đến 255</span>
  speed = constrain(speed * LEFT_OFFSET, -255, 255);

  <span class="comment">// 2. Kiểm tra MIN_PWM (Chống "ì" động cơ)</span>
  if (speed > 0 && speed < MIN_PWM) {
    speed = 0; <span class="comment">// Nếu tốc độ quá thấp, coi như 0</span>
  } else if (speed < 0 && speed > -MIN_PWM) {
    speed = 0;
  }

  <span class="comment">// 3. Ra lệnh cho động cơ</span>
  if (speed == 0) {
    motorLeftFront.run(RELEASE); <span class="comment">// Thả nổi (tiết kiệm điện)</span>
    motorLeftRear.run(RELEASE);
  } else if (speed > 0) {
    motorLeftFront.run(FORWARD); <span class="comment">// Chạy tiến</span>
    motorLeftRear.run(FORWARD);
    motorLeftFront.setSpeed(speed);
    motorLeftRear.setSpeed(speed);
  } else {
    motorLeftFront.run(BACKWARD); <span class="comment">// Chạy lùi</span>
    motorLeftRear.run(BACKWARD);
    motorLeftFront.setSpeed(abs(speed)); <span class="comment">// Tốc độ luôn là số dương</span>
    motorLeftRear.setSpeed(abs(speed));
  }
}

<span class="comment">// Hàm điều khiển 2 động cơ PHẢI (Tương tự hàm trái)</span>
void setRightMotors(int speed) {
    <span class="comment">// 1. Áp dụng offset (RIGHT_OFFSET)</span>
    speed = constrain(speed * RIGHT_OFFSET, -255, 255);

    <span class="comment">// 2. Kiểm tra MIN_PWM</span>
    if (speed > 0 && speed < MIN_PWM) {
      speed = 0;
    } else if (speed < 0 && speed > -MIN_PWM) {
      speed = 0;
    }

    <span class="comment">// 3. Ra lệnh cho động cơ</span>
    if (speed == 0) {
      motorRightFront.run(RELEASE);
      motorRightRear.run(RELEASE);
    } else if (speed > 0) {
      motorRightFront.run(FORWARD);
      motorRightRear.run(FORWARD);
      motorRightFront.setSpeed(speed);
      motorRightRear.setSpeed(speed);
    } else {
      motorRightFront.run(BACKWARD);
      motorRightRear.run(BACKWARD);
      motorRightFront.setSpeed(abs(speed));
      motorRightRear.setSpeed(abs(speed));
    }
}

<span class="comment">// Hàm dừng tất cả động cơ (KHÔNG điều khiển LED)</span>
void stopMotors() {
  motorLeftFront.run(RELEASE);
  motorLeftRear.run(RELEASE);
  motorRightFront.run(RELEASE);
  motorRightRear.run(RELEASE);
}

  <span class="comment">// Hàm dừng động cơ VÀ tắt LED Built-in</span>
  void stopMotorsAndLed() {
      stopMotors();
      digitalWrite(LED_BUILTIN, LOW);
  }


/*
 * =================================================================================
 * /* --- TARGET: CÁC HÀM CẢM BIẾN VÀ LOGIC --- */
 * CÁC HÀM CẢM BIẾN VÀ LOGIC
 * =================================================================================
 */

<span class="comment">// 1. Tự động hiệu chỉnh (Chạy 1 lần trong setup)</span>
void manual_calibration() {
  digitalWrite(LED_BUILTIN, HIGH); <span class="comment">// Bật LED báo hiệu đang calibration</span>
  Serial.println(F("Bat dau hieu chinh line. Lia robot qua vach DEN va TRANG trong 5 giay..."));
  unsigned long startTime = millis();
  SENSOR_MIN_CALI = 1023; SENSOR_MAX_CALI = 0; <span class="comment">// Reset min/max</span>
  
  <span class="comment">// Chạy vòng lặp trong 5 giây</span>
  while (millis() - startTime < 5000) {
    for (int j = 0; j < 4; j++) { <span class="comment">// Đọc cả 4 cảm biến</span>
      int val = analogRead(sens[j]);
      <span class="comment">// Liên tục cập nhật giá trị MAX (đen nhất) và MIN (trắng nhất)</span>
      if (val > SENSOR_MAX_CALI) SENSOR_MAX_CALI = val;
      if (val < SENSOR_MIN_CALI) SENSOR_MIN_CALI = val;
    }
    delay(20);
  }
  digitalWrite(LED_BUILTIN, LOW); <span class="comment">// Tắt LED báo hiệu xong</span>
  
  <span class="comment">// Tính ngưỡng rẽ (threshold) = (Đen + Trắng) / 2</span>
  threshold_for_turn = (SENSOR_MAX_CALI + SENSOR_MIN_CALI) / 2;
  
  Serial.println(F("--- Hieu chinh xong! ---"));
  Serial.print(F("SENSOR_MIN (Trang) tim thay: ")); Serial.println(SENSOR_MIN_CALI);
  Serial.print(F("SENSOR_MAX (Den) tim thay: ")); Serial.println(SENSOR_MAX_CALI);
  Serial.print(F("Nguong re (threshold) tinh duoc: ")); Serial.println(threshold_for_turn);
}

<span class="comment">// Hàm thực hiện và kiểm tra hoàn thành cú xoay MẠNH (Thông minh - V34)
// Hàm này được gọi liên tục trong linetracingMode khi isTurning = true</span>
void performTurn() {
  <span class="comment">// 1. Tiếp tục xoay (Xoay tại chỗ)</span>
  if (turningRight) { setLeftMotors(currentTurnSpeed); setRightMotors(-currentTurnSpeed); }
  else { setLeftMotors(-currentTurnSpeed); setRightMotors(currentTurnSpeed); }

  <span class="comment">// 2. Đọc 4 cảm biến (dùng giá trị bool) để tìm line MỘT CÁCH CHÍNH XÁC</span>
  bool s1 = (analogRead(sens[0]) > threshold_for_turn);
  bool s2 = (analogRead(sens[1]) > threshold_for_turn);
  bool s3 = (analogRead(sens[2]) > threshold_for_turn);
  bool s4 = (analogRead(sens[3]) > threshold_for_turn);

  bool lineFound = false; <span class="comment">// Cờ báo đã tìm thấy line</span>
  
  <span class="comment">// ----- LOGIC CỐT LÕI (V34) -----</span>
  if (turningRight) {
      <span class="comment">// Đang rẽ PHẢI, mục tiêu là tìm xx10 (S3=1, S4=0)
      // KHÔNG tìm 0011, vì 0011 có thể là mép của ngã ba tam giác</span>
      if (s3 && !s4) {
          lineFound = true;
          if (DEBUG_PRINT) Serial.println(F(" -> Re PHAI tim thay line (S3=1, S4=0)."));
      }
  } else {
      <span class="comment">// Đang rẽ TRÁI, mục tiêu là tìm 01xx (S2=1, S1=0)
      // KHÔNG tìm 1100.</span>
      if (s2 && !s1) {
          lineFound = true;
          if (DEBUG_PRINT) Serial.println(F(" -> Re TRAI tim thay line (S2=1, S1=0)."));
      }
  }

  <span class="comment">// 3. Kiểm tra timeout (Nếu xoay quá lâu mà không thấy line)</span>
  if (millis() - turnStartTime > currentMaxTurnTime) {
      if (DEBUG_PRINT) Serial.println(F(" -> Timeout! Dung xoay.")); lineFound = true;
  }

  <span class="comment">// 4. Hoàn thành xoay</span>
  if (lineFound) {
      stopMotorsAndLed(); <span class="comment">// Dừng 1 chút để ổn định</span>
      delay(50);
      <span class="comment">// Reset PID và vị trí</span>
      previous_error = 0; previous_I = 0; pre_pos = 1500.0;
      isTurning = false; <span class="comment">// Tắt cờ "đang bận rẽ"</span>
  }
}

<span class="comment">// 2. Logic dò line chính (Trái tim của robot)</span>
/* --- TARGET: linetracingMode() --- */
void linetracingMode() {

  <span class="comment">// --- ƯU TIÊN 0: Nếu đang bận rẽ, chỉ chạy performTurn() và thoát ---</span>
  if (isTurning) { performTurn(); return; }

  <span class="comment">// --- BƯỚC A: ĐỌC CẢM BIẾN VÀ CHUẨN HÓA (NORMALIZE) ---
  // Đọc giá trị 0-1023, chuẩn hóa về thang 0.0 (trắng) -> 1.0 (đen)</span>
  float eachError[4]; <span class="comment">// Mảng lưu giá trị 0.0 - 1.0</span>
  float sumError_all = 0; <span class="comment">// Tổng giá trị 4 cảm biến (dùng cho PID)</span>
  float see_line_threshold = 0.7; <span class="comment">// Ngưỡng 0.7 (70% đen) để quyết định là true</span>
  if (DEBUG_PRINT) Serial.print(F("Line (Raw): "));
  for (int i = 0; i < 4; i++) { 
    int val = analogRead(sens[i]); 
    if (DEBUG_PRINT) { Serial.print(val); Serial.print(" "); }
    <span class="comment">// Công thức chuẩn hóa (normalize)</span>
    eachError[i] = constrain((1.0 * (val - SENSOR_MIN_CALI)) / (1.0 * (SENSOR_MAX_CALI - SENSOR_MIN_CALI)), 0.0, 1.0); 
    sumError_all += eachError[i]; 
  }
  
  <span class="comment">/* --- TARGET: Logic "Grace Period" --- */
  // --- BƯỚC B: LOGIC "GRACE PERIOD" (V35) ---
  // Kiểm tra xem 10 giây đầu đã qua chưa</span>
  unsigned long currentTime = millis();
  bool isGracePeriod = (currentTime - programStartTime < INITIAL_GRACE_PERIOD);

  <span class="comment">// Đọc giá trị bool thô (raw) từ giá trị 0.0-1.0</span>
  bool s1_raw = (eachError[0] > see_line_threshold);
  bool s2_raw = (eachError[1] > see_line_threshold);
  bool s3_raw = (eachError[2] > see_line_threshold);
  bool s4_raw = (eachError[3] > see_line_threshold);

  bool s1, s2, s3, s4; <span class="comment">// Biến s# cuối cùng để dùng cho các CASE</span>

  if (isGracePeriod) {
    <span class="comment">// Nếu đang trong 10s đầu, BẮT BUỘC S1 và S4 = false
    // Điều này vô hiệu hóa tất cả các CASE rẽ (1.5, 2, 3A, 3B, 4C, 4D)</span>
    if (DEBUG_PRINT) Serial.print(F(" (Grace Period) "));
    s1 = false; <span class="comment">// Tắt S1</span>
    s2 = s2_raw;
    s3 = s3_raw;
    s4 = false; <span class="comment">// Tắt S4</span>
  } else {
    <span class="comment">// Sau 10s, dùng tất cả 4 cảm biến như bình thường</span>
    s1 = s1_raw;
    s2 = s2_raw;
    s3 = s3_raw;
    s4 = s4_raw;
  }

  <span class="comment">// --- BƯỚC C: HỆ THỐNG PHÂN LOẠI (CÁC CASE) ---
  // Sắp xếp theo thứ tự ưu tiên (if -> else if)</span>

  /* --- TARGET: CASE 1.5 --- */
  <span class="comment">// CASE 1.5: Ưu tiên rẽ trái khi thấy 1001 (Chỉ chạy sau 10s)
  // Ưu tiên CAO NHẤT</span>
  if (s1 && !s2 && !s3 && s4) {
    lostLineStartTime = 0; <span class="comment">// Reset timer mất line</span>
    if (!isTurning) { <span class="comment">// Chỉ bắt đầu rẽ nếu chưa rẽ</span>
        if (DEBUG_PRINT) Serial.println(F(" | CASE 1.5 (1001): Uu tien RE TRAI."));
        stabilityCounter = 0; <span class="comment">// Mất ổn định</span>
        <span class="comment">// Đặt cờ rẽ TRÁI</span>
        isTurning = true;
        turnStartTime = millis();
        turningRight = false; <span class="comment">// Rẽ TRÁI</span>
        currentTurnSpeed = 220;
        currentMaxTurnTime = 1200;
        performTurn(); <span class="comment">// Gọi lần đầu để bắt đầu xoay</span>
    }
    return; <span class="comment">// Rất quan trọng: Thoát hàm ngay</span>
  }

  /* --- TARGET: CASE 2 --- */
  <span class="comment">// CASE 2: NGÃ TƯ (1111) -> Rẽ Phải 90 độ (Tự động tắt trong 10s)</span>
  if (s1 && s2 && s3 && s4) {
    lostLineStartTime = 0; 
    if (DEBUG_PRINT) Serial.println(F(" | CASE 2: NGA TU (1111)! Bat dau RE PHAI 90 DO.")); 
    stabilityCounter = 0;
    <span class="comment">// Đặt cờ rẽ PHẢI</span>
    isTurning = true; 
    turnStartTime = millis(); 
    turningRight = true; 
    currentTurnSpeed = 220; 
    currentMaxTurnTime = 1500; 
    performTurn(); <span class="comment">// Gọi lần đầu</span>
    return;
  }
  /* --- TARGET: CASE 3A --- */
  <span class="comment">// CASE 3A: CUA GẮT TRÁI (1110) (Tự động tắt trong 10s)</span>
  else if (s1 && s2 && s3 && !s4) {
    lostLineStartTime = 0;
    if (!isTurning) {
      if (DEBUG_PRINT) Serial.println(F(" | CASE 3A: CUA GAT TRAI (1110)! Bat dau XOAY TRAI MANH."));
      stabilityCounter = 0;
      <span class="comment">// Đặt cờ rẽ TRÁI</span>
      isTurning = true;
      turnStartTime = millis();
      turningRight = false; 
      currentTurnSpeed = 220; 
      currentMaxTurnTime = 1200; 
      performTurn(); 
    } else if (DEBUG_PRINT) {
      Serial.println(F(" | CASE 3A: Ignored (already turning)."));
    }
    return; 
  }
  /* --- TARGET: CASE 3B --- */
  <span class="comment">// CASE 3B: CUA GẮT PHẢI (0111) (Tự động tắt trong 10s)</span>
  else if (!s1 && s2 && s3 && s4) {
    lostLineStartTime = 0;
    if (!isTurning) { 
      if (DEBUG_PRINT) Serial.println(F(" | CASE 3B: CUA GAT PHAI (0111)! Bat dau XOAY PHAI MANH."));
      stabilityCounter = 0;
      <span class="comment">// Đặt cờ rẽ PHẢI</span>
      isTurning = true;
      turnStartTime = millis();
      turningRight = true; 
      currentTurnSpeed = 220; 
      currentMaxTurnTime = 1200; 
      performTurn(); 
    } else if (DEBUG_PRINT) {
      Serial.println(F(" | CASE 3B: Ignored (already turning)."));
    }
    return; 
  }
  /* --- TARGET: CASE 4A --- */
  <span class="comment">// CASE 4A: PHỤC HỒI CUA TRÁI (0100) (Hoạt động bình thường)
  // Line hơi lệch, chỉ thấy S2</span>
  else if (!s1 && s2 && !s3 && !s4) {
      lostLineStartTime = 0; 
      if (DEBUG_PRINT) Serial.println(F(" | CASE 4A: PHUC HOI TRAI (0100)! Re trai nhe...")); 
      stabilityCounter = 0;
      setLeftMotors(-100); <span class="comment">// Quay bánh trái lùi</span>
      setRightMotors(180); <span class="comment">// Quay bánh phải tiến -> rẽ trái nhanh</span>
      previous_error = -0.8; <span class="comment">// Cập nhật lỗi để PID và CASE 5 biết</span>
  }
  /* --- TARGET: CASE 4B --- */
  <span class="comment">// CASE 4B: PHỤC HỒI CUA PHẢI (0010) (Hoạt động bình thường)
  // Line hơi lệch, chỉ thấy S3</span>
  else if (!s1 && !s2 && s3 && !s4) {
      lostLineStartTime = 0; 
      if (DEBUG_PRINT) Serial.println(F(" | CASE 4B: PHUC HOI PHAI (0010)! Re phai nhe...")); 
      stabilityCounter = 0;
      setLeftMotors(180); <span class="comment">// Rẽ phải nhanh</span>
      setRightMotors(-100);
      previous_error = 0.8;
  }
  /* --- TARGET: CASE 4C --- */
  <span class="comment">// CASE 4C: PHỤC HỒI CUA TRÁI CỰC GẮT (1000) (Tự động tắt trong 10s)
  // Line lệch nhiều, chỉ thấy S1</span>
  else if (s1 && !s2 && !s3 && !s4) {
    lostLineStartTime = 0; 
    if (DEBUG_PRINT) Serial.println(F(" | CASE 4C: PHUC HOI TRAI (1000)! Re trai GAT (Xoay)...")); 
    stabilityCounter = 0;
    setLeftMotors(-200); <span class="comment">// Xoay tại chỗ để tìm line</span>
    setRightMotors(200);
    previous_error = -1.5; <span class="comment">// Lỗi rất âm (bên trái)</span>
  }
  /* --- TARGET: CASE 4D --- */
  <span class="comment">// CASE 4D: PHỤC HỒI CUA PHẢI CỰC GẮT (0001) (Tự động tắt trong 10s)
  // Line lệch nhiều, chỉ thấy S4</span>
  else if (!s1 && !s2 && !s3 && s4) {
    lostLineStartTime = 0; 
    if (DEBUG_PRINT) Serial.println(F(" | CASE 4D: PHUC HOI PHAI (0001)! Re phai GAT (Xoay)...")); 
    stabilityCounter = 0;
    setLeftMotors(200); <span class="comment">// Xoay tại chỗ</span>
    setRightMotors(-200);
    previous_error = 1.5; <span class="comment">// Lỗi rất dương (bên phải)</span>
  }
  /* --- TARGET: CASE 5 --- */
  <span class="comment">// CASE 5: MẤT LINE (0000) (Hoạt động bình thường)</span>
  else if (!s1 && !s2 && !s3 && !s4) {
    stabilityCounter = 0;
    <span class="comment">// Nếu đây là lần đầu tiên mất line, bắt đầu đếm giờ</span>
    if (lostLineStartTime == 0) {
      lostLineStartTime = millis(); 
      if (DEBUG_PRINT) Serial.print(F(" | CASE 5: VUA MAT LINE (0000)! Bat dau timeout..."));
    }

    <span class="comment">// Kiểm tra xem đã mất line quá 500ms chưa</span>
    if (millis() - lostLineStartTime > LOST_LINE_TIMEOUT) {
      <span class="comment">// Đã quá 500ms -> Chuyển sang xoay tròn tại chỗ để TÍCH CỰC tìm line</span>
      if (DEBUG_PRINT) Serial.println(F(" -> HET TIMEOUT! Chuyen sang TIM KIEM XOAY TRON."));
      int searchTurnSpeed = 160;
      <span class="comment">// Xoay theo hướng cuối cùng thấy line (thông minh)</span>
      if (previous_error < -0.5) { 
        if (DEBUG_PRINT) Serial.println(F(" (Xoay TRAI tim)"));
        setLeftMotors(-searchTurnSpeed); setRightMotors(searchTurnSpeed);
      } else if (previous_error > 0.5) {
        if (DEBUG_PRINT) Serial.println(F(" (Xoay PHAI tim)"));
        setLeftMotors(searchTurnSpeed); setRightMotors(-searchTurnSpeed);
      } else {
        if (DEBUG_PRINT) Serial.println(F(" (Khong ro huong, xoay PHAI)"));
        setLeftMotors(searchTurnSpeed); setRightMotors(-searchTurnSpeed);
      }
    } else {
      <span class="comment">// CHƯA quá 500ms -> Tiếp tục "dò dẫm" theo hướng cũ</span>
      if (DEBUG_PRINT) Serial.print(F(" -> Dang timeout, chay theo huong cu...")); 
      int recoverySpeed = 150;
      if (previous_error < -0.5) { if (DEBUG_PRINT) Serial.println(F(" (Re trai tim)")); setLeftMotors(-recoverySpeed / 2); setRightMotors(recoverySpeed); }
      else if (previous_error > 0.5) { if (DEBUG_PRINT) Serial.println(F(" (Re phai tim)")); setLeftMotors(recoverySpeed); setRightMotors(-recoverySpeed / 2); }
      else { if (DEBUG_PRINT) Serial.println(F(" (Di thang tim)")); setLeftMotors(recoverySpeed); setRightMotors(recoverySpeed); }
    }
  }
  /* --- TARGET: CASE 6 --- */
  <span class="comment">// CASE 6: BÌNH THƯỜNG - PID
  // Đây là trường hợp phổ biến nhất (ví dụ: 0110, 0010, 0100...)</span>
  else {
    lostLineStartTime = 0; <span class="comment">// Reset timer mất line vì đang thấy line</span>
    float pos_pid = 0.0; <span class="comment">// Vị trí line (0.0 - 3000.0)</span>
    
    <span class="comment">// Tính PID dựa trên grace period</span>
    if (isGracePeriod) {
        <span class="comment">// TRONG 10s ĐẦU: Chỉ dùng S2 và S3, trọng số 1000 và 2000</span>
        float sumError_pid = 0.0; 
        pos_pid += eachError[1] * 1000.0;
        pos_pid += eachError[2] * 2000.0;
        sumError_pid = eachError[1] + eachError[2];
        if (sumError_pid < 0.01) pos_pid = 1500.0; <span class="comment">// Nếu (0000), giả định ở giữa</span>
        else pos_pid /= sumError_pid; <span class="comment">// Tính trung bình trọng số</span>
        pre_pos = pos_pid; <span class="comment">// Vẫn cập nhật pre_pos</span>
    } else {
        <span class="comment">// SAU 10s: Dùng cả 4 cảm biến, trọng số 0, 1000, 2000, 3000</span>
        pos_pid += eachError[0] * 0.0;
        pos_pid += eachError[1] * 1000.0;
        pos_pid += eachError[2] * 2000.0;
        pos_pid += eachError[3] * 3000.0;
        if (sumError_all < 0.01) pos_pid = pre_pos; <span class="comment">// Nếu (0000), dùng vị trí cũ</span>
        else pos_pid /= sumError_all; <span class="comment">// Tính trung bình trọng số</span>
        pre_pos = pos_pid;
    }

    <span class="comment">// Cập nhật stabilityCounter (cho PID Thích ứng)</span>
    if (pos_pid > 1100 && pos_pid < 1900) stabilityCounter++; <span class="comment">// Đang ở giữa -> ổn định</span>
    else stabilityCounter = 0; <span class="comment">// Lệch ra ngoài -> mất ổn định</span>
    
    <span class="comment">// ----- LOGIC PID THÍCH ỨNG (ADAPTIVE) -----</span>
    float current_initSpeed, current_Kp;
    if (stabilityCounter > 20) { 
      <span class="comment">// ỔN ĐỊNH (Đường thẳng): Tốc độ CAO, Kp THẤP (chạy mượt)</span>
      if (DEBUG_PRINT) Serial.print(F(" (Stable - Kp THAP) ")); 
      current_initSpeed = 240; 
      current_Kp = 40.0; 
    } else { 
      <span class="comment">// MẤT ỔN ĐỊNH (Vào cua): Tốc độ THẤP, Kp CAO (bám cua gắt)</span>
      if (DEBUG_PRINT) Serial.print(F(" (Unstable - Kp CAO) ")); 
      current_initSpeed = 210; 
      current_Kp = 100.0; 
    }
    
    <span class="comment">// ----- TÍNH TOÁN PID -----</span>
    <span class="comment">// 1. Tính Error (chuẩn hóa về -1.0 đến 1.0)</span>
    error = (pos_pid - 1500.0) / 500.0; 
    <span class="comment">// 2. Tính P, I, D</span>
    P = error;
    I = I + previous_I;
    I = constrain(I, -100.0, 100.0); <span class="comment">// Giới hạn I (chống "wind-up")</span>
    D = error - previous_error;
    <span class="comment">// 3. Tính PID_value tổng</span>
    PID_value = (current_Kp * P) + (Ki * I) + (Kd * D); 
    <span class="comment">// 4. Lưu lại giá trị cho vòng lặp sau</span>
    previous_I = I; 
    previous_error = error;
    
    <span class="comment">// ----- TÍNH TỐC ĐỘ MOTOR -----</span>
    <span class="comment">// (initSpeed + PID) cho bánh trái, (initSpeed - PID) cho bánh phải</span>
    int left_motor_speed = constrain(current_initSpeed + PID_value, -255, 255); 
    int right_motor_speed = constrain(current_initSpeed - PID_value, -255, 255);
    
    <span class="comment">// ----- RA LỆNH CHO MOTOR -----</span>
    setLeftMotors(left_motor_speed); 
    setRightMotors(right_motor_speed);
    
    <span class="comment">// In debug</span>
    if (DEBUG_PRINT) { Serial.print(F(" | CASE 6: PID | Pos: ")); Serial.print(pos_pid); Serial.print(F(" | Err: ")); Serial.print(error);
      Serial.print(F(" | PID: ")); Serial.print(PID_value); Serial.print(F(" | L/R: ")); Serial.print(left_motor_speed); Serial.print(F("/")); Serial.println(right_motor_speed); }
  }
} <span class="comment">// Kết thúc hàm linetracingMode</span>


<span class="comment">// 3. Kiểm tra cảm biến siêu âm</span>
float checkUltrasonicDistance() {
  <span class="comment">// 1. Tạo 1 xung 10us ở chân TRIG</span>
  digitalWrite(ULTRA_TRIG_PIN, LOW); delayMicroseconds(2);
  digitalWrite(ULTRA_TRIG_PIN, HIGH); delayMicroseconds(10);
  digitalWrite(ULTRA_TRIG_PIN, LOW);
  
  <span class="comment">// 2. Đọc thời gian (us) chân ECHO ở mức HIGH, timeout 50ms</span>
  long duration = pulseIn(ULTRA_ECHO_PIN, HIGH, 50000); 
  
  <span class="comment">// 3. Chuyển đổi thời gian sang cm</span>
  float distance = duration * 0.034 / 2.0;
  
  if (duration == 0 || distance <= 0) {
    return 999.0; <span class="comment">// Trả về 999 nếu không thấy (timeout)</span>
  } else {
    return distance;
  }
}

<span class="comment">// Hàm quét siêu âm xung quanh và quyết định hướng rẽ</span>
bool scanSurroundings() {
    float distLeft = 999.0;
    float distRight = 999.0;
    if (DEBUG_PRINT) Serial.println(F("    Scanning surroundings..."));
    
    <span class="comment">// 1. Quét trái</span>
    myServo.write(SCAN_LEFT);
    delay(SCAN_DELAY); 
    distLeft = checkUltrasonicDistance();
    if (DEBUG_PRINT) { Serial.print(F("      Left distance: ")); Serial.println(distLeft); }
    
    <span class="comment">// 2. Quét phải</span>
    myServo.write(SCAN_RIGHT);
    delay(SCAN_DELAY);
    distRight = checkUltrasonicDistance();
    if (DEBUG_PRINT) { Serial.print(F("      Right distance: ")); Serial.println(distRight); }
    
    <span class="comment">// 3. Về giữa</span>
    myServo.write(SCAN_CENTER);
    delay(SCAN_DELAY / 2); 
    
    <span class="comment">// 4. Quyết định</span>
    if (distRight > distLeft) {
        if (DEBUG_PRINT) Serial.println(F("      Decision: Turn RIGHT first."));
        return true; <span class="comment">// True = rẽ phải</span>
    } else {
        if (DEBUG_PRINT) Serial.println(F("      Decision: Turn LEFT first."));
        return false; <span class="comment">// False = rẽ trái</span>
    }
}

<span class="comment">// Hàm thực hiện các bước tránh vật cản (Máy trạng thái - State Machine)</span>
void performAvoidance() {
    unsigned long currentTime = millis();
    switch (avoidState) {
        <span class="comment">// BƯỚC 1: QUAY 90 ĐỘ (THEO HƯỚNG ĐÃ QUYẾT ĐỊNH)</span>
        case 1: 
            if (avoidTurnRight) {
                 if (DEBUG_PRINT) Serial.println(F(" | AVOID STATE 1: Turning RIGHT (chosen)..."));
                 setLeftMotors(TURN_SPEED); setRightMotors(-TURN_SPEED);
            } else {
                 if (DEBUG_PRINT) Serial.println(F(" | AVOID STATE 1: Turning LEFT (chosen)..."));
                 setLeftMotors(-TURN_SPEED); setRightMotors(TURN_SPEED);
            }
            avoidStartTime = currentTime; <span class="comment">// Bắt đầu đếm giờ</span>
            avoidState = 11; <span class="comment">// Chuyển sang trạng thái "đang chờ"</span>
            break;
        case 11: <span class="comment">// Trạng thái chờ...</span>
            if (currentTime - avoidStartTime > TURN_DURATION) { <span class="comment">// Hết 600ms</span>
                 if (DEBUG_PRINT) Serial.println(F("    -> Initial Turn Complete."));
                 stopMotorsAndLed(); delay(100);
                 avoidState = 2; <span class="comment">// Chuyển sang BƯỚC 2</span>
            }
            break;
            
        <span class="comment">// BƯỚC 2: ĐI THẲNG VÒNG QUA</span>
        case 2: 
            if (DEBUG_PRINT) Serial.println(F(" | AVOID STATE 2: Going STRAIGHT..."));
            setLeftMotors(AVOID_SPEED); setRightMotors(AVOID_SPEED);
            avoidStartTime = currentTime;
            avoidState = 22; <span class="comment">// Chuyển sang "đang chờ"</span>
            break;
        case 22: 
             if (currentTime - avoidStartTime > STRAIGHT_DURATION) { <span class="comment">// Hết 1000ms</span>
                 if (DEBUG_PRINT) Serial.println(F("    -> Go STRAIGHT Complete."));
                 stopMotorsAndLed(); delay(100);
                 avoidState = 3; <span class="comment">// Chuyển sang BƯỚC 3</span>
             }
            break;
            
        <span class="comment">// BƯỚC 3: QUAY 90 ĐỘ (NGƯỢC LẠI VỚI BƯỚC 1)</span>
        case 3: 
             if (avoidTurnRight) { <span class="comment">// Nếu B1 rẽ phải -> B3 rẽ trái</span>
                 if (DEBUG_PRINT) Serial.println(F(" | AVOID STATE 3: Turning LEFT (opposite)..."));
                 setLeftMotors(-TURN_SPEED); setRightMotors(TURN_SPEED);
             } else { <span class="comment">// Nếu B1 rẽ trái -> B3 rẽ phải</span>
                 if (DEBUG_PRINT) Serial.println(F(" | AVOID STATE 3: Turning RIGHT (opposite)..."));
                 setLeftMotors(TURN_SPEED); setRightMotors(-TURN_SPEED);
             }
            avoidStartTime = currentTime;
            avoidState = 33; <span class="comment">// Chuyển sang "đang chờ"</span>
            break;
        case 33: 
            if (currentTime - avoidStartTime > TURN_DURATION) { <span class="comment">// Hết 600ms</span>
                 if (DEBUG_PRINT) Serial.println(F("    -> Second Turn Complete."));
                 stopMotorsAndLed(); delay(100);
                 avoidState = 4; <span class="comment">// Chuyển sang BƯỚC 4</span>
            }
            break;
            
        <span class="comment">// BƯỚC 4: ĐI THẲNG TÌM LINE</span>
        case 4: 
             if (DEBUG_PRINT) Serial.println(F(" | AVOID STATE 4: Searching for LINE..."));
             setLeftMotors(SEARCH_SPEED); setRightMotors(SEARCH_SPEED);
             avoidStartTime = currentTime; <span class="comment">// Bắt đầu đếm giờ (cho timeout)</span>
             avoidState = 44;
        case 44: <span class="comment">// Liên tục kiểm tra line</span>
            bool lineDetected = false;
            if (DEBUG_PRINT) Serial.print(F("    Searching... Sensors: "));
            for (int i = 0; i < 4; i++) { 
              int val = analogRead(sens[i]); 
              if (DEBUG_PRINT) { Serial.print(val); Serial.print(" "); }
              if (val > threshold_for_turn) lineDetected = true; <span class="comment">// Thấy bất kỳ line nào</span>
            }
            if (DEBUG_PRINT) Serial.println();

            if (lineDetected) { 
                 if (DEBUG_PRINT) Serial.println(F("    -> LINE FOUND! Avoidance complete."));
                 stopMotorsAndLed(); delay(100);
                 isAvoidingObstacle = false; avoidState = 0; <span class="comment">// Tắt cờ -> Trả về loop()</span>
                 <span class="comment">// Reset PID</span>
                 previous_error = 0; previous_I = 0; pre_pos = 1500.0; stabilityCounter = 0;
            }
            else if (currentTime - avoidStartTime > SEARCH_TIMEOUT) { <span class="comment">// Quá 3s</span>
                 if (DEBUG_PRINT) Serial.println(F("    -> SEARCH TIMEOUT! Stopping."));
                 stopMotorsAndLed();
                 isAvoidingObstacle = false; avoidState = 0;
                 robotState = 0; <span class="comment">// Bỏ cuộc, TẮT robot</span>
            }
            break;
    }
}


/*
 * =================================================================================
 * /* --- TARGET: HÀM SETUP VÀ LOOP CHÍNH --- */
 * HÀM SETUP VÀ LOOP CHÍNH
 * =================================================================================
 */

void setup() {
  Serial.begin(9600);
  Serial.println(F("--- KHOI DONG XE DÒ LINE (V36 - Don Gian Comment) ---"));

  <span class="comment">// Cài đặt I/O</span>
  pinMode(ULTRA_TRIG_PIN, OUTPUT);
  pinMode(ULTRA_ECHO_PIN, INPUT);
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, LOW);

  <span class="comment">// Gắn servo và quay về giữa</span>
  myServo.attach(SERVO_PIN);
  myServo.write(SCAN_CENTER); 

  <span class="comment">// Chạy hiệu chỉnh (Quan trọng)</span>
  manual_calibration(); 

  <span class="comment">// Bắt đầu đếm 10 giây "Grace Period"</span>
  programStartTime = millis(); 
  
  robotState = 1; <span class="comment">// Tự động BẬT</span>
  Serial.println(F("Da hieu chinh xong. Tu dong BAT XE. (Grace Period 10s)"));

  stopMotorsAndLed(); <span class="comment">// Tắt LED ban đầu</span>
}

void loop() {
  <span class="comment">// ----- HỆ THỐNG ƯU TIÊN -----</span>
  
  <span class="comment">// ƯU TIÊN 1: Đang bận TRÁNH VẬT CẢN</span>
  if (isAvoidingObstacle) {
      digitalWrite(LED_BUILTIN, HIGH); <span class="comment">// Bật LED khi đang tránh</span>
      performAvoidance(); <span class="comment">// Chỉ chạy hàm tránh</span>
      delay(10);
      return; <span class="comment">// Thoát loop(), không làm gì khác</span>
  }

  <span class="comment">// ƯU TIÊN 2: Robot đang TẮT</span>
  if (robotState == 0) { stopMotorsAndLed(); return; }

  <span class="comment">// Nếu không TẮT, bật LED</span>
  digitalWrite(LED_BUILTIN, HIGH);

  <span class="comment">// ƯU TIÊN 3: Kiểm tra VẬT CẢN MỚI</span>
  float currentDistance = checkUltrasonicDistance(); 
  if (currentDistance < OBSTACLE_DISTANCE) {
    
    <span class="comment">// Chỉ bắt đầu tránh nếu chưa tránh (isAvoidingObstacle=false)
    // VÀ không đang bận rẽ (isTurning=false)</span>
    if (!isAvoidingObstacle && !isTurning) {
        if (DEBUG_PRINT) { Serial.print(F("CASE 1: VAT CAN o phia truoc (")); Serial.print(currentDistance); Serial.println(F("cm)! Bat dau quet...")); }
        stopMotorsAndLed(); 
        delay(200); <span class="comment">// Dừng 1 chút</span>
        avoidTurnRight = scanSurroundings(); <span class="comment">// Quét 2 bên và quyết định hướng</span>
        isAvoidingObstacle = true; <span class="comment">// Bật cờ "đang bận tránh"</span>
        avoidState = 1; <span class="comment">// Bắt đầu máy trạng thái từ BƯỚC 1</span>
    } else if (DEBUG_PRINT && isTurning){ 
         <span class="comment">// Nếu thấy vật cản KHI ĐANG RẼ, bỏ qua (ưu tiên RẼ)</span>
         Serial.println(F("CASE 1: VAT CAN! Ignored (turning)."));
         stopMotorsAndLed(); 
    }
  }
  <span class="comment">// ƯU TIÊN 4: DÒ LINE (Mặc định)</span>
  else {
    <span class="comment">// Nếu không có gì ở trên, chạy logic dò line bình thường</span>
    linetracingMode();
  }
  delay(10); <span class="comment">// Delay nhỏ để ổn định vòng lặp</span>
}
</code></pre>
            </div>
        </div>

    </main>
    
    <script>
        let originalCodeHTML = '';
        
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& nghĩa là toàn bộ chuỗi khớp
        }

        document.addEventListener('DOMContentLoaded', function() {
            const codeEl = document.getElementById('code-content');
            
            // Thêm class 'comment' vào các comment để CSS
            let rawHTML = codeEl.innerHTML;
            rawHTML = rawHTML.replace(/<span class="comment">/g, '<span class="comment" style="color: #6ee7b7; font-style: italic;">'); // Làm cho comment nổi bật hơn
            
            codeEl.innerHTML = rawHTML;
            originalCodeHTML = codeEl.innerHTML;
            
            renderLogicChart();
        });

        function scrollToCode(searchText) {
            const codeEl = document.getElementById('code-content');
            
            // Đặt lại HTML về gốc để xóa highlight cũ
            codeEl.innerHTML = originalCodeHTML;
            
            // Chuẩn bị searchText để dùng trong RegExp
            // Chúng ta cần tìm `searchText` nhưng nó ở trong comment `/* --- TARGET: ... --- */`
            const fullSearchText = `/* --- TARGET: ${searchText} --- */`;
            const safeSearchText = escapeRegExp(fullSearchText);
            const regex = new RegExp(safeSearchText, 'g');

            let targetFound = false;

            // Thay thế text tìm thấy bằng span highlight
            const newHTML = originalCodeHTML.replace(regex, (match) => {
                targetFound = true;
                return `<span id="scroll-target" class="highlight">${match}</span>`;
            });

            if (targetFound) {
                codeEl.innerHTML = newHTML;
                const target = document.getElementById('scroll-target');
                
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // Xóa highlight sau 3 giây
                    setTimeout(() => {
                        codeEl.innerHTML = originalCodeHTML;
                    }, 3000);
                }
            } else {
                // Nếu không tìm thấy, thử tìm hàm (fallback)
                scrollToCodeFallback(searchText);
            }
        }
        
        function scrollToCodeFallback(searchText) {
            const codeEl = document.getElementById('code-content');
            const safeSearchText = escapeRegExp(searchText);
            const regex = new RegExp(safeSearchText, 'g');
            let targetFound = false;
            
             const newHTML = originalCodeHTML.replace(regex, (match) => {
                targetFound = true;
                return `<span id="scroll-target" class="highlight">${match}</span>`;
            });
            
            if (targetFound) {
                codeEl.innerHTML = newHTML;
                const target = document.getElementById('scroll-target');
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    setTimeout(() => {
                        codeEl.innerHTML = originalCodeHTML;
                    }, 3000);
                }
            }
        }

        function copyCode() {
            const codeContent = document.getElementById('code-content').innerText;
            const copyBtn = document.getElementById('copy-btn');
            
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            
            try {
                document.execCommand('copy');
                copyBtn.innerText = 'Đã sao chép!';
                copyBtn.classList.add('bg-green-600');
                
                setTimeout(() => {
                    copyBtn.innerText = 'Sao chép Mã';
                    copyBtn.classList.remove('bg-green-600');
                }, 2000);
            } catch (err) {
                copyBtn.innerText = 'Lỗi!';
                copyBtn.classList.add('bg-red-600');
            }
            
            document.body.removeChild(tempTextArea);
        }

        function renderLogicChart() {
            const ctx = document.getElementById('logicCasesChart').getContext('2d');
            
            const chartData = {
                labels: [
                    'PID (CASE 6)',
                    'Cua Gắt / Ngã Rẽ (CASE 3A, 3B)',
                    'Phục Hồi Lệch Line (CASE 4A, 4B)',
                    'Phục Hồi Lệch Nhiều (CASE 4C, 4D)',
                    'Ngã Tư (CASE 2)',
                    'Trường hợp đặc biệt (CASE 1.5 - 1001)',
                    'Mất Line (CASE 5)'
                ],
                datasets: [{
                    label: 'Mức độ ưu tiên / Tần suất xử lý',
                    data: [1, 5, 4, 6, 7, 8, 3], 
                    backgroundColor: [
                        'rgba(54, 162, 235, 0.6)', // Blue
                        'rgba(255, 159, 64, 0.6)', // Orange
                        'rgba(75, 192, 192, 0.6)', // Teal
                        'rgba(255, 206, 86, 0.6)', // Yellow
                        'rgba(255, 99, 132, 0.6)',  // Red
                        'rgba(153, 102, 255, 0.6)',// Purple
                        'rgba(100, 100, 100, 0.6)' // Gray
                    ],
                    borderColor: [
                        'rgba(54, 162, 235, 1)',
                        'rgba(255, 159, 64, 1)',
                        'rgba(75, 192, 192, 1)',
                        'rgba(255, 206, 86, 1)',
                        'rgba(255, 99, 132, 1)',
                        'rgba(153, 102, 255, 1)',
                        'rgba(100, 100, 100, 1)'
                    ],
                    borderWidth: 1
                }]
            };

            new Chart(ctx, {
                type: 'bar',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Mức độ ưu tiên (Giá trị cao hơn = Ưu tiên cao hơn)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            beginAtZero: true
                        },
                        y: {
                            ticks: {
                                autoSkip: false,
                                font: {
                                    size: 13
                                },
                                callback: function(value, index, values) {
                                    const label = this.getLabelForValue(value);
                                    if (label.length > 25) {
                                        return label.substring(0, 25) + '...';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Phân loại các trường hợp logic dò line (CASEs)',
                            font: {
                                size: 18,
                                weight: 'bold'
                            }
                        },
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    label += `Ưu tiên ${context.raw}`;
                                    return label;
                                },
                                title: function(context) {
                                    return context[0].label;
                                }
                            }
                        }
                    }
                }
            });
        }
    </script>
</body>
</html>

