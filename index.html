<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale-1.0">
    <title>Trình mô phỏng Xe Dò Line (v6 - Gemini AI)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        /* ... (Toàn bộ CSS từ v5 được giữ nguyên) ... */
        canvas.draw-mode-freehand { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='black' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 20l-7.5-7.5 4.5-4.5L12 11l7.5 7.5L16 20z'/><path d='M12 11V4'/></svg>") 0 24, crosshair; }
        canvas.draw-mode-line { cursor: crosshair; }
        canvas.draw-mode-rect { cursor: crosshair; }
        canvas.draw-mode-eraser { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='black' stroke-width='2'><path d='M18.5 2.5a2.12 2.12 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z'/><path d='m15 5 3 3'/><path d='M6 16l-3 3.5a2.12 2.12 0 0 0 3 3L9.5 19'/></svg>") 0 24, crosshair; }
        canvas.simulate-mode { cursor: default; }
        canvas.place-car-mode { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'><path fill='black' d='M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z'/></svg>") 12 12, pointer; }
        
        #logPanel::-webkit-scrollbar, #codeEditor::-webkit-scrollbar { width: 6px; }
        #logPanel::-webkit-scrollbar-track, #codeEditor::-webkit-scrollbar-track { background: #4b5563; }
        #logPanel::-webkit-scrollbar-thumb, #codeEditor::-webkit-scrollbar-thumb { background: #9ca3af; border-radius: 3px; }

        .tool-button:disabled {
            background-color: #3b82f6;
            color: white;
            opacity: 1;
        }
        
        .grid-background {
            background-image:
                linear-gradient(to right, #e5e7eb 1px, transparent 1px),
                linear-gradient(to bottom, #e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #codeEditor {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            background-color: #1f2937;
            color: #d1d5db;
            border: 1px solid #4b5563;
            border-radius: 0.375rem;
        }
        
        /* CSS cho AI Modal (MỚI) */
        #aiModal {
            transition: opacity 0.3s ease-in-out;
        }
        #aiModalContent {
            max-height: 80vh;
        }
        #aiModalContent article h1 { font-size: 1.5rem; font-weight: bold; margin-top: 1rem; }
        #aiModalContent article h2 { font-size: 1.25rem; font-weight: bold; margin-top: 0.75rem; }
        #aiModalContent article ul { list-style-type: disc; margin-left: 1.5rem; }
        #aiModalContent article code { background-color: #374151; color: #f9fafb; padding: 0.125rem 0.25rem; border-radius: 0.25rem; }
        #aiModalContent article pre { background-color: #1f2937; color: #d1d5db; padding: 0.5rem; border-radius: 0.375rem; overflow-x: auto; }

    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <h1 class="text-3xl font-bold text-gray-800 mb-4">Trình mô phỏng Xe Dò Line (v6 - Gemini AI)</h1>

    <!-- Bảng điều khiển chính -->
    <div class="flex flex-wrap justify-center gap-2 mb-2">
        <!-- ... (Tất cả các nút từ v5 được giữ nguyên) ... -->
        <button id="drawButton" class="px-5 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 disabled:opacity-50" title="Chuyển sang chế độ vẽ">
            Vẽ
        </button>
        <button id="placeCarButton" class="px-5 py-2 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75 disabled:opacity-50" title="Click và Kéo để đặt vị trí và hướng xe">
            Đặt Xe
        </button>
        <button id="simulateButton" class="px-5 py-2 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75" title="Chạy mô phỏng">
            Chạy
        </button>
        <button id="stopButton" class="px-5 py-2 bg-red-600 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75" title="Dừng mô phỏng" disabled>
            Dừng
        </button>
        <button id="resetCarButton" class="px-5 py-2 bg-yellow-500 text-white font-semibold rounded-lg shadow-md hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-400 focus:ring-opacity-75" title="Đưa xe về vị trí xuất phát đã đặt">
            Reset Xe
        </button>
        <button id="clearMapButton" class="px-5 py-2 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-gray-600 focus:ring-opacity-75" title="Xóa toàn bộ bản đồ">
            Xóa Map
        </button>
        <button id="saveMapButton" class="px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700" title="Sao chép dữ liệu map vào clipboard">
            Lưu Map
        </button>
        <button id="loadMapButton" class="px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700" title="Tải map từ chuỗi text">
            Tải Map
        </button>
    </div>

    <!-- Thanh công cụ vẽ -->
    <div id="drawingTools" class="flex flex-wrap justify-center items-center gap-2 mb-4 p-2 bg-gray-100 rounded-lg shadow">
        <!-- ... (Tất cả các công cụ vẽ từ v5 được giữ nguyên) ... -->
        <button id="toolFreehand" class="tool-button px-3 py-2 bg-white text-gray-800 rounded shadow hover:bg-blue-100 disabled:hover:bg-blue-600">Vẽ Tự Do</button>
        <button id="toolLine" class="tool-button px-3 py-2 bg-white text-gray-800 rounded shadow hover:bg-blue-100 disabled:hover:bg-blue-600">Đường Thẳng</button>
        <button id="toolArc" class="tool-button px-3 py-2 bg-white text-gray-800 rounded shadow hover:bg-blue-100 disabled:hover:bg-blue-600">Cung (3-click)</button>
        <button id="toolTriangle" class="tool-button px-3 py-2 bg-white text-gray-800 rounded shadow hover:bg-blue-100 disabled:hover:bg-blue-600">Tam Giác (3-click)</button>
        <button id="toolRect" class="tool-button px-3 py-2 bg-white text-gray-800 rounded shadow hover:bg-blue-100 disabled:hover:bg-blue-600">Chữ Nhật</button>
        <button id="toolEraser" class="tool-button px-3 py-2 bg-white text-gray-800 rounded shadow hover:bg-blue-100 disabled:hover:bg-blue-600">Tẩy</button>
        <button id="undoButton" class="tool-button px-3 py-2 bg-white text-gray-800 rounded shadow hover:bg-blue-100 disabled:opacity-50" disabled>Undo</button>
        <button id="redoButton" class="tool-button px-3 py-2 bg-white text-gray-800 rounded shadow hover:bg-blue-100 disabled:opacity-50" disabled>Redo</button>
        <button id="toggleGridButton" class="tool-button px-3 py-2 bg-white text-gray-800 rounded shadow hover:bg-blue-100">Hiện Lưới</button>
        <div class="flex items-center space-x-2 bg-white p-2 rounded shadow">
            <label for="lineWidthSlider" class="text-sm">Nét vẽ:</label>
            <input id="lineWidthSlider" type="range" min="2" max="50" value="18" class="w-24">
        </div>
    </div>

    <!-- Tùy chọn mô phỏng -->
    <div id="simulationOptions" class="flex flex-wrap justify-center items-center gap-2 mb-4 p-2 bg-gray-100 rounded-lg shadow">
        <!-- ... (Thanh trượt tốc độ từ v5 được giữ nguyên) ... -->
        <div class="flex items-center space-x-2 bg-white p-2 rounded shadow">
            <label for="carSpeedSlider" class="text-sm">Tốc độ xe:</label>
            <input id="carSpeedSlider" type="range" min="0.5" max="5" step="0.1" value="1.5" class="w-32">
            <span id="carSpeedValue" class="text-sm w-8 text-right">1.5</span>
        </div>
    </div>

    <!-- Khu vực chính: Canvas và Cột bên phải -->
    <div class="flex flex-col md:flex-row w-full max-w-screen-2xl">
        <!-- Canvas -->
        <div class="flex-grow">
            <canvas id="simulationCanvas" width="1200" height="800" class="rounded-lg shadow-lg border-2 border-gray-400"></canvas>
        </div>

        <!-- Cột bên phải (Log, Code Editor, AI Tools) -->
        <div id="rightColumn" class="md:ml-4 mt-4 md:mt-0 w-full md:w-96 flex-shrink-0 flex flex-col gap-4">
            <!-- Bảng Log -->
            <div id="logPanelContainer" class="flex-shrink-0">
                <div id="logPanel" class="bg-gray-800 text-white p-4 rounded-lg shadow-lg h-72 md:h-80 overflow-y-auto">
                    <h3 class="text-lg font-bold mb-2 text-white border-b border-gray-600 pb-2">Bảng Ghi Log</h3>
                    <pre id="logContent" class="text-sm text-gray-200">
--- TRẠNG THÁI XE ---
Chờ mô phỏng...
                    </pre>
                </div>
            </div>
            
            <!-- Trình soạn thảo code -->
            <div id="codeEditorContainer" class="flex-grow flex flex-col">
                <h3 class="text-lg font-bold mb-2 text-gray-800">Trình soạn thảo Code (Bộ Não Xe)</h3>
                <textarea id="codeEditor" class="w-full flex-grow h-64 md:h-auto" style="min-height: 250px;"></textarea>
                <button id="loadCodeButton" class="mt-2 w-full px-5 py-2 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500">
                    Nạp Code (Cập nhật Bộ Não)
                </button>
            </div>
            
            <!-- Bảng điều khiển AI (MỚI) -->
            <div id="aiControls" class="flex flex-col gap-2 p-4 bg-gray-100 rounded-lg shadow">
                 <h3 class="text-lg font-bold text-gray-800">Công cụ Gemini AI ✨</h3>
                 <textarea id="aiPromptInput" class="w-full h-24 p-2 border border-gray-300 rounded-md" placeholder="Mô tả logic bạn muốn (ví dụ: 'rẽ trái khi 2 cảm biến trái chạm vạch') hoặc đặt câu hỏi về code..."></textarea>
                 <div class="flex gap-2">
                    <button id="generateCodeButton" class="flex-1 px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-wait">
                        ✨ Tạo Code
                    </button>
                    <button id="debugCodeButton" class="flex-1 px-4 py-2 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 disabled:opacity-50 disabled:cursor-wait">
                        ✨ Phân tích Code
                    </button>
                 </div>
                 <p id="aiStatus" class="text-sm text-gray-600 text-center h-4"></p>
            </div>

        </div>
    </div>
    
    <!-- AI Modal (MỚI) - Ẩn mặc định -->
    <div id="aiModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 opacity-0 pointer-events-none">
        <div class="bg-white rounded-lg shadow-2xl w-full max-w-2xl">
            <div class="flex justify-between items-center p-4 border-b">
                <h2 class="text-xl font-bold text-gray-800">✨ Phân tích từ Gemini AI</h2>
                <button id="closeAiModalButton" class="text-gray-500 hover:text-gray-800 text-3xl">&times;</button>
            </div>
            <div id="aiModalContent" class="p-6 overflow-y-auto">
                <article class="prose prose-sm max-w-none"></article>
            </div>
        </div>
    </div>


    <script>
        // --- Lấy các phần tử DOM ---
        // ... (Tất cả DOM elements từ v5) ...
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const logContent = document.getElementById('logContent');
        
        const drawButton = document.getElementById('drawButton');
        const placeCarButton = document.getElementById('placeCarButton');
        const simulateButton = document.getElementById('simulateButton');
        const stopButton = document.getElementById('stopButton');
        const resetCarButton = document.getElementById('resetCarButton');
        const clearMapButton = document.getElementById('clearMapButton');
        const saveMapButton = document.getElementById('saveMapButton');
        const loadMapButton = document.getElementById('loadMapButton');
        
        const drawingTools = document.getElementById('drawingTools');
        const toolFreehand = document.getElementById('toolFreehand');
        const toolLine = document.getElementById('toolLine');
        const toolArc = document.getElementById('toolArc');
        const toolTriangle = document.getElementById('toolTriangle');
        const toolRect = document.getElementById('toolRect');
        const toolEraser = document.getElementById('toolEraser');
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton');
        const toggleGridButton = document.getElementById('toggleGridButton');
        const lineWidthSlider = document.getElementById('lineWidthSlider');
        
        const simulationOptions = document.getElementById('simulationOptions');
        const carSpeedSlider = document.getElementById('carSpeedSlider');
        const carSpeedValue = document.getElementById('carSpeedValue');
        
        const codeEditor = document.getElementById('codeEditor');
        const loadCodeButton = document.getElementById('loadCodeButton');

        // DOM elements MỚI cho AI
        const aiPromptInput = document.getElementById('aiPromptInput');
        const generateCodeButton = document.getElementById('generateCodeButton');
        const debugCodeButton = document.getElementById('debugCodeButton');
        const aiStatus = document.getElementById('aiStatus');
        const aiModal = document.getElementById('aiModal');
        const aiModalContent = document.getElementById('aiModalContent').querySelector('article');
        const closeAiModalButton = document.getElementById('closeAiModalButton');


        // --- CẤU HÌNH ---
        // ... (Tất cả cấu hình từ v5) ...
        let LINE_COLOR = '#000000';
        const BACKGROUND_COLOR = '#FFFFFF';
        let LINE_WIDTH = 18;
        let ERASER_WIDTH = 20;
        const SENSOR_COLOR_ON = 'red';
        const SENSOR_COLOR_OFF = 'green';
        const GRID_SIZE = 20;
        
        // --- BIẾN TRẠNG THÁI ---
        // ... (Tất cả biến trạng thái từ v5) ...
        let currentMode = 'draw';
        let currentDrawTool = 'freehand';
        let isRunning = false;
        let isDrawing = false; 
        let isGridVisible = false;
        
        let animationFrameId = null;
        let mapImageData = null; 
        
        let lineStartPoint = null;
        let previewMapData = null; 
        
        let drawState = { clickCount: 0, p1: null, p2: null };
        
        let history = [];
        let historyIndex = -1;
        
        let initialCarX = 100;
        let initialCarY = 750; 
        let initialCarAngle = -Math.PI / 2; 

        // --- Đối tượng Xe ---
        // ... (Giữ nguyên 100% đối tượng 'car' từ v5) ...
        const car = {
            x: initialCarX,
            y: initialCarY,
            width: 20,
            height: 30,
            angle: initialCarAngle,
            speed: 1.5,
            turnSpeed: 0.05,
            sensors: [
                { id: 'SL', x: -12, y: -15, value: 0 },
                { id: 'SR', x: 12, y: -15, value: 0 },
                { id: 'ML', x: -5, y: -18, value: 0 },
                { id: 'MR', x: 5, y: -18, value: 0 }
            ],
            wheels: [
                { x: -15, y: -10, width: 6, height: 12 },
                { x: 15, y: -10, width: 6, height: 12 },
                { x: -15, y: 10, width: 6, height: 12 },
                { x: 15, y: 10, width: 6, height: 12 }
            ],
            draw: function() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = 'blue';
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.fillStyle = 'cyan';
                ctx.beginPath();
                ctx.moveTo(0, -this.height / 2 - 5);
                ctx.lineTo(-5, -this.height / 2);
                ctx.lineTo(5, -this.height / 2);
                ctx.closePath();
                ctx.fill();
                this.wheels.forEach(wheel => {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(wheel.x - wheel.width / 2, wheel.y - wheel.height / 2, wheel.width, wheel.height);
                });
                this.sensors.forEach(sensor => {
                    ctx.fillStyle = sensor.value ? SENSOR_COLOR_ON : SENSOR_COLOR_OFF;
                    ctx.beginPath();
                    ctx.arc(sensor.x, sensor.y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
                ctx.restore();
            },
            update: function(leftSpeed, rightSpeed) {
                const linearSpeed = (leftSpeed + rightSpeed) / 2 * this.speed; 
                const angularSpeed = (rightSpeed - leftSpeed) / this.width; 
                
                this.angle += angularSpeed * this.turnSpeed;
                this.x += Math.cos(this.angle) * linearSpeed;
                this.y += Math.sin(this.angle) * linearSpeed;
            },
            readSensors: function() {
                this.sensors.forEach(sensor => {
                    const cosA = Math.cos(this.angle);
                    const sinA = Math.sin(this.angle);
                    const sensorX = this.x + sensor.x * cosA - sensor.y * sinA;
                    const sensorY = this.y + sensor.x * sinA + sensor.y * cosA;
                    
                    try {
                        const pixelData = ctx.getImageData(Math.round(sensorX), Math.round(sensorY), 1, 1).data;
                        const isBlack = pixelData[0] < 50 && pixelData[1] < 50 && pixelData[2] < 50;
                        sensor.value = isBlack ? 1 : 0;
                    } catch (e) {
                        sensor.value = 0;
                    }
                });
            },
            reset: function() {
                this.x = initialCarX;
                this.y = initialCarY;
                this.angle = initialCarAngle;
            }
        };

        // --- BỘ NÃO XE (LOGIC CỦA BẠN) ---
        // ... (Giữ nguyên 100% đối tượng 'CarBrain' từ v5) ...
        const CarBrain = {
            lastError: 0,
            integral: 0,
            KP: 0.8,
            KI: 0.001,
            KD: 0.1,

            reset: function() {
                this.lastError = 0;
                this.integral = 0;
            },
            
            update: function(sensors) {
                try {
                    return this.customUpdate(sensors, this);
                } catch (e) {
                    console.error("Lỗi trong code 'Bộ Não Xe' của bạn:", e);
                    stopSimulationWithError(`Lỗi code: ${e.message}`);
                    return {
                        motorSpeeds: { left: 0, right: 0 },
                        logData: { status: "LỖI CODE! Đã dừng." }
                    };
                }
            },
            
            customUpdate: function(sensors, brain) {
                // Đây là code mẫu, sẽ bị ghi đè
                // (Code mẫu từ v5 được giữ nguyên ở đây)
                const sL = sensors.find(s => s.id === 'SL').value;
                const sR = sensors.find(s => s.id === 'SR').value;
                const mL = sensors.find(s => s.id === 'ML').value;
                const mR = sensors.find(s => s.id === 'MR').value;
                
                let error = 0;
                let logData = { status: "Đang dò line..." };
                const baseSpeed = 1.0; 
                
                if (sL === 1 && sR === 0) error = -1;
                else if (sL === 0 && sR === 1) error = 1;
                else if (mL === 1 && mR === 0) error = -0.5;
                else if (mL === 0 && mR === 1) error = 0.5;
                else if (sL === 0 && sR === 0 && mL === 0 && mR === 0) {
                    logData.status = "Mất line!";
                    error = brain.lastError > 0 ? 2 : -2; 
                } else if (sL === 1 && sR === 1) {
                    logData.status = "Trên vạch đôi / Ngã rẽ?";
                    error = 0;
                } else if (mL === 1 && mR === 1) {
                    error = 0;
                } else {
                    error = 0;
                }
                
                const proportional = error;
                brain.integral += error;
                if (brain.integral > 20) brain.integral = 20;
                if (brain.integral < -20) brain.integral = -20;
                
                const derivative = error - brain.lastError;
                brain.lastError = error;
                
                const correction = (brain.KP * proportional) + (brain.KI * brain.integral) + (brain.KD * derivative);
                
                let leftSpeed = baseSpeed + correction;
                let rightSpeed = baseSpeed - correction;
                
                leftSpeed = Math.max(0, Math.min(1.5, leftSpeed));
                rightSpeed = Math.max(0, Math.min(1.5, rightSpeed));
                
                logData.error = error;
                logData.integral = brain.integral.toFixed(2);
                logData.derivative = derivative.toFixed(2);
                logData.correction = correction.toFixed(2);
                logData.leftSpeed = leftSpeed.toFixed(2);
                logData.rightSpeed = rightSpeed.toFixed(2);
                
                return {
                    motorSpeeds: { left: leftSpeed, right: rightSpeed },
                    logData: logData
                };
            }
        };

        // --- LOGIC GEMINI API (MỚI) ---
        const apiKey = ""; // Canvas sẽ tự động thêm key
        const genAIApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        async function callGeminiAPI(systemPrompt, userPrompt) {
            setAiLoading(true);
            aiStatus.textContent = "Đang kết nối với Gemini AI...";
            
            const payload = {
                contents: [{ parts: [{ text: userPrompt }] }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };

            try {
                const response = await fetch(genAIApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.json();
                    throw new Error(`API Error: ${response.status} - ${errorBody.error?.message || response.statusText}`);
                }

                const result = await response.json();
                const candidate = result.candidates?.[0];
                
                if (candidate && candidate.content?.parts?.[0]?.text) {
                    aiStatus.textContent = "AI đã phản hồi!";
                    setAiLoading(false);
                    return candidate.content.parts[0].text;
                } else {
                    throw new Error("Không nhận được nội dung hợp lệ từ AI.");
                }
            } catch (e) {
                console.error("Lỗi gọi Gemini API:", e);
                aiStatus.textContent = `Lỗi: ${e.message}`;
                setAiLoading(false);
                return null;
            }
        }
        
        function setAiLoading(isLoading) {
            generateCodeButton.disabled = isLoading;
            debugCodeButton.disabled = isLoading;
            if (isLoading) {
                aiStatus.textContent = "AI đang xử lý...";
            } else {
                 setTimeout(() => { aiStatus.textContent = ""; }, 3000);
            }
        }

        // Nút Tạo Code (MỚI)
        generateCodeButton.addEventListener('click', async () => {
            const userPrompt = aiPromptInput.value;
            if (!userPrompt) {
                alert("Vui lòng nhập mô tả logic của bạn vào ô bên trên.");
                return;
            }
            
            const systemPrompt = `
You are an expert JavaScript programmer specializing in line follower robot logic.
Your task is to generate ONLY the JavaScript code for the body of a function: \`customUpdate(sensors, brain)\`.
Do NOT include the function definition \`function customUpdate(sensors, brain) { ... }\` or any surrounding text, comments, or markdown ticks (\`\`\`).
You must generate only the raw JavaScript code for the function's body.

The 'sensors' array has this structure:
[
  { id: 'SL', value: 0 }, // Sensor Left (Ngoài cùng trái)
  { id: 'SR', value: 0 }, // Sensor Right (Ngoài cùng phải)
  { id: 'ML', value: 0 }, // Motor Left (Trong trái)
  { id: 'MR', value: 0 }  // Motor Right (Trong phải)
]
'value' is 1 (black line) or 0 (white background).

The 'brain' object contains:
- brain.lastError (number)
- brain.integral (number)
- brain.KP (number)
- brain.KI (number)
- brain.KD (number)
You MUST use these properties for PID calculations. Access them via 'brain.KP', 'brain.lastError', etc.

Your code MUST return an object with this exact structure:
{
  motorSpeeds: { left: number, right: number },
  logData: { status: string, ...any_other_logs }
}
Respond in Vietnamese for comments if any.
`;
            
            let generatedCode = await callGeminiAPI(systemPrompt, userPrompt);
            
            if (generatedCode) {
                // Làm sạch code (loại bỏ markdown ticks nếu AI cố tình thêm vào)
                generatedCode = generatedCode.replace(/^```javascript\n?|```$/g, "").trim();
                
                codeEditor.value = generatedCode;
                aiStatus.textContent = "Đã tạo code! Đang nạp code...";
                // Tự động nạp code
                loadCodeButton.click();
            }
        });

        // Nút Phân tích Code (MỚI)
        debugCodeButton.addEventListener('click', async () => {
            const userCode = codeEditor.value;
            if (!userCode) {
                alert("Không có code nào trong trình soạn thảo để phân tích.");
                return;
            }
            
            const systemPrompt = `
Bạn là một chuyên gia đánh giá code (code reviewer) chuyên về logic robot dò line (PID, v.v.).
Nhiệm vụ của bạn là phân tích code JavaScript của người dùng.
Hãy phản hồi bằng Tiếng Việt.
1. Giải thích logic của code một cách rõ ràng, từng bước một.
2. Xác định các lỗi tiềm ẩn hoặc các trường hợp biên (ví dụ: ngã rẽ 90 độ, ngã ba, mất line).
3. Gợi ý các cải tiến để code chạy tốt hơn hoặc ổn định hơn.
Hãy định dạng câu trả lời của bạn rõ ràng bằng Markdown (dùng #, *, \`code\`).
`;
            const userPrompt = `
Hãy phân tích code xe dò line sau đây, giải thích logic, tìm lỗi và gợi ý cải tiến:

\`\`\`javascript
${userCode}
\`\`\`
`;
            
            const analysis = await callGeminiAPI(systemPrompt, userPrompt);
            
            if (analysis) {
                // Sử dụng một thư viện (hoặc hàm đơn giản) để chuyển Markdown sang HTML
                // Vì không có thư viện, tôi sẽ thay thế các thẻ cơ bản
                let htmlAnalysis = analysis
                    .replace(/```javascript\n/g, '<pre><code>')
                    .replace(/```\n/g, '</code></pre>')
                    .replace(/```/g, '</code></pre>')
                    .replace(/`([^`]+)`/g, '<code>$1</code>')
                    .replace(/^# (.*$)/gmi, '<h1>$1</h1>')
                    .replace(/^## (.*$)/gmi, '<h2>$1</h2>')
                    .replace(/\n\*(.*)/g, '<ul>\n  <li>$1</li>\n</ul>')
                    .replace(/<\/ul>\n<ul>/g, '') // Gộp các list
                    .replace(/\n\n/g, '<br><br>');
                
                aiModalContent.innerHTML = htmlAnalysis;
                showAiModal();
            }
        });
        
        function showAiModal() {
            aiModal.classList.remove('opacity-0', 'pointer-events-none');
        }
        function hideAiModal() {
            aiModal.classList.add('opacity-0', 'pointer-events-none');
        }
        closeAiModalButton.addEventListener('click', hideAiModal);
        aiModal.addEventListener('click', (e) => {
            if (e.target === aiModal) { // Chỉ đóng khi click vào nền mờ
                hideAiModal();
            }
        });


        // --- CODE EDITOR LOGIC ---
        // ... (Giữ nguyên codeTemplate và hàm 'loadCodeButton' từ v5) ...
        const codeTemplate = `
// 'sensors' là mảng cảm biến đầu vào
// 'brain' là đối tượng CarBrain, dùng để truy cập:
// - brain.lastError, brain.integral (để tính PID)
// - brain.KP, brain.KI, brain.KD (hằng số PID)

const sL = sensors.find(s => s.id === 'SL').value;
const sR = sensors.find(s => s.id === 'SR').value;
const mL = sensors.find(s => s.id === 'ML').value;
const mR = sensors.find(s => s.id === 'MR').value;

let error = 0;
let logData = { status: "Đang dò line..." };
const baseSpeed = 1.0; 

// --- Logic dò line của bạn ---
if (sL === 1 && sR === 0) error = -1;
else if (sL === 0 && sR === 1) error = 1;
else if (mL === 1 && mR === 0) error = -0.5;
else if (mL === 0 && mR === 1) error = 0.5;
else if (sL === 0 && sR === 0 && mL === 0 && mR === 0) {
    logData.status = "Mất line!";
    error = brain.lastError > 0 ? 2 : -2; 
} else if (sL === 1 && sR === 1) {
    logData.status = "Trên vạch đôi / Ngã rẽ?";
    error = 0;
} else if (mL === 1 && mR === 1) {
    error = 0;
} else {
    error = 0;
}

// --- Tính toán PID ---
const proportional = error;
brain.integral += error;
if (brain.integral > 20) brain.integral = 20;
if (brain.integral < -20) brain.integral = -20;

const derivative = error - brain.lastError;
brain.lastError = error;

const correction = (brain.KP * proportional) + (brain.KI * brain.integral) + (brain.KD * derivative);

let leftSpeed = baseSpeed + correction;
let rightSpeed = baseSpeed - correction;

leftSpeed = Math.max(0, Math.min(1.5, leftSpeed));
rightSpeed = Math.max(0, Math.min(1.5, rightSpeed));

// --- Chuẩn bị log ---
logData.error = error;
logData.integral = brain.integral.toFixed(2);
logData.derivative = derivative.toFixed(2);
logData.correction = correction.toFixed(2);
logData.leftSpeed = leftSpeed.toFixed(2);
logData.rightSpeed = rightSpeed.toFixed(2);

// --- Trả về kết quả ---
return {
    motorSpeeds: { left: leftSpeed, right: rightSpeed },
    logData: logData
};
`;
        codeEditor.value = codeTemplate.trim();
        
        loadCodeButton.addEventListener('click', () => {
            const userCode = codeEditor.value;
            try {
                const newUpdateFunction = new Function('sensors', 'brain', userCode);
                CarBrain.customUpdate = newUpdateFunction;
                CarBrain.reset();
                
                loadCodeButton.textContent = "Đã nạp code thành công!";
                loadCodeButton.classList.remove('bg-green-600', 'hover:bg-green-700');
                loadCodeButton.classList.add('bg-blue-500');
                setTimeout(() => {
                    loadCodeButton.textContent = "Nạp Code (Cập nhật Bộ Não)";
                    loadCodeButton.classList.remove('bg-blue-500');
                    loadCodeButton.classList.add('bg-green-600', 'hover:bg-green-700');
                }, 2000);
                
            } catch (e) {
                console.error("Lỗi cú pháp trong code của bạn:", e);
                alert(`Lỗi cú pháp trong code của bạn:\n\n${e.message}\n\nHãy kiểm tra lại và nhấn 'Nạp Code'.`);
            }
        });

        
        // --- CÁC HÀM CẬP NHẬT GIAO DIỆN ---
        // ... (Giữ nguyên các hàm updateLogPanel, stopSimulationWithError từ v5) ...
        function updateLogPanel(carState, sensors, carBrainLog) {
            logContent.innerHTML = `
--- TRẠNG THÁI XE ---
X: ${carState.x.toFixed(2)}
Y: ${carState.y.toFixed(2)}
Góc: ${(carState.angle * 180 / Math.PI).toFixed(2)}°

--- CẢM BIẾN ---
[SL, SR, ML, MR]
[ ${sensors.find(s => s.id === 'SL').value},  ${sensors.find(s => s.id === 'SR').value},  ${sensors.find(s => s.id === 'ML').value},  ${sensors.find(s => s.id === 'MR').value}]

--- BỘ NÃO (LOGIC) ---
Trạng thái: ${carBrainLog.status || "Đang tính..."}
Lỗi (Error): ${carBrainLog.error}
Tích phân (I): ${carBrainLog.integral || 0}
Đạo hàm (D): ${carBrainLog.derivative || 0}
Điều chỉnh: ${carBrainLog.correction || "0.00"}

--- ĐỘNG CƠ ---
Trái: ${carBrainLog.leftSpeed || "0.00"}
Phải: ${carBrainLog.rightSpeed || "0.00"}
            `;
        }

        function stopSimulationWithError(message) {
            isRunning = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            setMode('draw');
            logContent.innerHTML = `
--- TRẠNG THÁI XE ---
ĐÃ DỪNG!
Lý do: ${message}
Đã quay về chế độ Vẽ.
            `;
        }
        
        // --- VÒNG LẶP MÔ PHỎNG (GAME LOOP) ---
        // ... (Giữ nguyên 100% từ v5) ...
        function simulationLoop() {
            if (!isRunning || currentMode !== 'simulate' || !mapImageData) return;
            
            ctx.putImageData(mapImageData, 0, 0);
            
            car.readSensors();
            
            const decision = CarBrain.update(car.sensors); 
            if (!decision) return;
            
            const motorSpeeds = decision.motorSpeeds;
            car.update(motorSpeeds.left, motorSpeeds.right);

            if (car.x < 0 || car.x > canvas.width || car.y < 0 || car.y > canvas.height) {
                stopSimulationWithError("Xe đã đi ra khỏi đường biên.");
                return;
            }
            
            car.draw();
            updateLogPanel(car, car.sensors, decision.logData);
            
            animationFrameId = requestAnimationFrame(simulationLoop);
        }

        // --- CÁC HÀM VẼ CƠ BẢN (Grid, Clear, RedrawAll) ---
        // ... (Giữ nguyên 100% từ v5) ...
        function clearCanvas() {
            ctx.fillStyle = BACKGROUND_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function drawGrid() {
            if (!isGridVisible) return;
            ctx.save();
            ctx.strokeStyle = "#e5e7eb";
            ctx.lineWidth = 1;
            
            for (let x = GRID_SIZE; x < canvas.width; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = GRID_SIZE; y < canvas.height; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            ctx.restore();
        }
        
        function redrawAll(drawCar = true) {
            if (historyIndex > -1) {
                ctx.putImageData(history[historyIndex], 0, 0);
            } else {
                clearCanvas();
            }
            
            drawGrid();
            
            if (drawCar) {
                drawCarAtCurrentInitialPosition();
            }
        }

        // --- LỊCH SỬ (UNDO/REDO) ---
        // ... (Giữ nguyên 100% từ v5) ...
        function saveHistory() {
            history.splice(historyIndex + 1);
            history.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
            historyIndex++;
            updateUndoRedoButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                ctx.putImageData(history[historyIndex], 0, 0);
                drawGrid();
                drawCarAtCurrentInitialPosition();
                updateUndoRedoButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                ctx.putImageData(history[historyIndex], 0, 0);
                drawGrid();
                drawCarAtCurrentInitialPosition();
                updateUndoRedoButtons();
            }
        }

        function updateUndoRedoButtons() {
            undoButton.disabled = (historyIndex <= 0);
            redoButton.disabled = (historyIndex >= history.length - 1);
        }
        
        function resetHistory() {
            history = [];
            historyIndex = -1;
            clearCanvas();
            saveHistory();
        }
        

        // --- QUẢN LÝ CHẾ ĐỘ VÀ CÔNG CỤ ---
        // ... (Giữ nguyên 100% từ v5, bao gồm setMode, setDrawTool, ...) ...
        function resetDrawState() {
            drawState.clickCount = 0;
            drawState.p1 = null;
            drawState.p2 = null;
            previewMapData = null; 
            isDrawing = false; 
            lineStartPoint = null;
        }

        function setDrawTool(tool) {
            currentDrawTool = tool;
            resetDrawState();
            
            toolFreehand.disabled = (tool === 'freehand');
            toolLine.disabled = (tool === 'line');
            toolArc.disabled = (tool === 'arc');
            toolTriangle.disabled = (tool === 'triangle');
            toolRect.disabled = (tool === 'rect');
            toolEraser.disabled = (tool === 'eraser');
            
            canvas.classList.remove('draw-mode-freehand', 'draw-mode-line', 'draw-mode-rect', 'draw-mode-eraser');
            if (tool === 'freehand') canvas.classList.add('draw-mode-freehand');
            else if (tool === 'eraser') canvas.classList.add('draw-mode-eraser');
            else if (tool === 'rect') canvas.classList.add('draw-mode-rect');
            else canvas.classList.add('draw-mode-line'); 
        }
        
        function setMode(mode) {
            currentMode = mode;
            isRunning = false; 
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            canvas.classList.remove('draw-mode-freehand', 'draw-mode-line', 'draw-mode-rect', 'draw-mode-eraser', 'place-car-mode', 'simulate-mode');
            
            drawButton.disabled = false;
            placeCarButton.disabled = false;
            simulateButton.disabled = false;
            stopButton.disabled = true;
            clearMapButton.disabled = false;
            resetCarButton.disabled = false;
            saveMapButton.disabled = false;
            loadMapButton.disabled = false;
            simulationOptions.style.display = 'none'; 
            
            if (mode === 'draw') {
                drawingTools.style.display = 'flex'; 
                drawButton.disabled = true;
                
                if (mapImageData) { 
                     ctx.putImageData(mapImageData, 0, 0);
                     mapImageData = null; 
                } 
                
                redrawAll(true);
                
                setDrawTool(currentDrawTool); 
                updateUndoRedoButtons(); 
            } else if (mode === 'place_car') {
                drawingTools.style.display = 'none'; 
                canvas.classList.add('place-car-mode');
                placeCarButton.disabled = true;

                redrawAll(true);
                
                ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                ctx.font = "16px Inter";
                ctx.textAlign = "center";
                ctx.fillText("Click và Kéo để đặt vị trí và hướng xe. Thả chuột để hoàn tất.", canvas.width / 2, 30);

            } else if (mode === 'simulate') {
                drawingTools.style.display = 'none'; 
                simulationOptions.style.display = 'flex'; 
                canvas.classList.add('simulate-mode');
                simulateButton.disabled = true;
                stopButton.disabled = false;
                drawButton.disabled = false;
                placeCarButton.disabled = true;
                clearMapButton.disabled = true; 
                saveMapButton.disabled = true;
                loadMapButton.disabled = true;

                redrawAll(false);
                mapImageData = ctx.getImageData(0, 0, canvas.width, canvas.height); 
                
                car.reset();
                CarBrain.reset();
                isRunning = true;
                simulationLoop();
            }
        }
        
        function drawCarAtCurrentInitialPosition() {
            const tempX = car.x;
            const tempY = car.y;
            const tempAngle = car.angle;
            
            car.x = initialCarX;
            car.y = initialCarY;
            car.angle = initialCarAngle;
            car.readSensors(); 
            car.draw();
            
            car.x = tempX;
            car.y = tempY;
            car.angle = tempAngle;
        }

        // --- GÁN SỰ KIỆN CHO CÁC NÚT ---
        // ... (Giữ nguyên các hàm gán sự kiện cho các nút từ v5) ...
        drawButton.addEventListener('click', () => setMode('draw'));
        placeCarButton.addEventListener('click', () => setMode('place_car'));
        simulateButton.addEventListener('click', () => setMode('simulate'));
        stopButton.addEventListener('click', () => setMode('draw')); 

        resetCarButton.addEventListener('click', () => {
            isRunning = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            CarBrain.reset();
            
            redrawAll(true);

            if (currentMode === 'simulate') {
                redrawAll(false);
                mapImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                car.reset(); 
                isRunning = true;
                simulationLoop();
            }
        });

        clearMapButton.addEventListener('click', () => {
            if (currentMode !== 'simulate') { 
                if (confirm('Bạn có chắc muốn xóa toàn bộ bản đồ đã vẽ?')) {
                    mapImageData = null;
                    initialCarX = 100;
                    initialCarY = 750; 
                    initialCarAngle = -Math.PI / 2;
                    resetHistory(); 
                    setMode('draw'); 
                }
            }
        });

        toolFreehand.addEventListener('click', () => setDrawTool('freehand'));
        toolLine.addEventListener('click', () => setDrawTool('line'));
        toolArc.addEventListener('click', () => setDrawTool('arc'));
        toolTriangle.addEventListener('click', () => setDrawTool('triangle'));
        toolRect.addEventListener('click', () => setDrawTool('rect'));
        toolEraser.addEventListener('click', () => setDrawTool('eraser'));
        
        toggleGridButton.addEventListener('click', () => {
            isGridVisible = !isGridVisible;
            toggleGridButton.textContent = isGridVisible ? "Ẩn Lưới" : "Hiện Lưới";
            toggleGridButton.classList.toggle('bg-blue-200', isGridVisible);
            redrawAll(true);
}       );
        lineWidthSlider.addEventListener('input', (e) => {
            const width = parseInt(e.target.value, 10);
            LINE_WIDTH = width;
            ERASER_WIDTH = width + 2;
        });
        
        carSpeedSlider.addEventListener('input', (e) => {
            const speed = parseFloat(e.target.value);
            car.speed = speed;
            carSpeedValue.textContent = speed.toFixed(1);
        });

        undoButton.addEventListener('click', undo);
        redoButton.addEventListener('click', redo);
        
        saveMapButton.addEventListener('click', () => {
            if (currentMode === 'simulate') return;
            try {
                const mapData = history[historyIndex];
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                tempCanvas.getContext('2d').putImageData(mapData, 0, 0);
                
                const dataUrl = tempCanvas.toDataURL();
                
                navigator.clipboard.writeText(dataUrl).then(() => {
                    alert("Đã sao chép dữ liệu bản đồ vào clipboard!");
                }, () => {
                    alert("Không thể sao chép tự động. Vui lòng thử lại.");
                });
            } catch (e) {
                alert("Lỗi khi lưu bản đồ: " + e.message);
            }
        });

        loadMapButton.addEventListener('click', () => {
            if (currentMode === 'simulate') return;
            const dataUrl = prompt("Dán (Paste) chuỗi dữ liệu bản đồ (Base64) vào đây:");
            if (dataUrl) {
                const img = new Image();
                img.onload = function() {
                    clearCanvas();
                    ctx.drawImage(img, 0, 0);
                    saveHistory();
                    redrawAll(true);
                };
                img.onerror = function() {
                    alert("Dữ liệu bản đồ không hợp lệ.");
                };
                img.src = dataUrl;
            }
        });


        // --- GÁN SỰ KIỆN VẼ BẰNG CHUỘT ---
        // ... (Giữ nguyên 100% các hàm mouse event (mousedown, mousemove, mouseup, mouseleave) từ v5) ...
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }
        
        function setupLineStyle() {
            ctx.strokeStyle = LINE_COLOR;
            ctx.lineWidth = LINE_WIDTH;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
        }
        
        function setupEraserStyle() {
            ctx.strokeStyle = BACKGROUND_COLOR;
            ctx.lineWidth = ERASER_WIDTH;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
        }

        function drawArc(p1, p2, p3) {
            setupLineStyle();
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.quadraticCurveTo(p2.x, p2.y, p3.x, p3.y);
            ctx.stroke();
        }
        function drawTriangle(p1, p2, p3) {
            setupLineStyle();
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.closePath(); 
            ctx.stroke();
        }
        function drawRect(p1, p2) {
            setupLineStyle();
            ctx.strokeRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
        }

        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);
            
            if (currentMode === 'draw') {
                if (currentDrawTool === 'freehand' || currentDrawTool === 'eraser') {
                    isDrawing = true;
                    (currentDrawTool === 'eraser' ? setupEraserStyle() : setupLineStyle());
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                    previewMapData = ctx.getImageData(0, 0, canvas.width, canvas.height); 
                } else if (currentDrawTool === 'line' || currentDrawTool === 'rect') {
                    isDrawing = true;
                    lineStartPoint = pos;
                    previewMapData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                } else if (currentDrawTool === 'arc') {
                    drawState.clickCount++;
                    if (drawState.clickCount === 1) { 
                        drawState.p1 = pos;
                        previewMapData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    } else if (drawState.clickCount === 2) { 
                        drawState.p2 = pos;
                    } else if (drawState.clickCount === 3) { 
                        ctx.putImageData(previewMapData, 0, 0); 
                        drawGrid();
                        drawArc(drawState.p1, drawState.p2, pos); 
                        resetDrawState();
                        saveHistory(); 
                    }
                } else if (currentDrawTool === 'triangle') {
                    drawState.clickCount++;
                    if (drawState.clickCount === 1) { 
                        drawState.p1 = pos;
                        previewMapData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    } else if (drawState.clickCount === 2) { 
                        drawState.p2 = pos;
                    } else if (drawState.clickCount === 3) { 
                        ctx.putImageData(previewMapData, 0, 0); 
                        drawGrid();
                        drawTriangle(drawState.p1, drawState.p2, pos); 
                        resetDrawState();
                        saveHistory(); 
                    }
                }
            } else if (currentMode === 'place_car') {
                isDrawing = true; 
                initialCarX = pos.x;
                initialCarY = pos.y;
                previewMapData = ctx.getImageData(0, 0, canvas.width, canvas.height); 
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);

            if (currentMode === 'place_car' && isDrawing) {
                initialCarAngle = Math.atan2(pos.y - initialCarY, pos.x - initialCarX);
                
                ctx.putImageData(previewMapData, 0, 0);
                drawGrid();
                
                ctx.beginPath();
                ctx.moveTo(initialCarX, initialCarY);
                ctx.lineTo(pos.x, pos.y);
                ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                drawCarAtCurrentInitialPosition(); 
                return;
            }

            if (currentMode !== 'draw') return;
            if (!isDrawing && drawState.clickCount === 0) return; 

            if (isDrawing && (currentDrawTool === 'freehand' || currentDrawTool === 'eraser')) {
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
            } else if (isDrawing && currentDrawTool === 'line') {
                ctx.putImageData(previewMapData, 0, 0);
                drawGrid();
                setupLineStyle();
                ctx.beginPath();
                ctx.moveTo(lineStartPoint.x, lineStartPoint.y);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
            } else if (isDrawing && currentDrawTool === 'rect') {
                ctx.putImageData(previewMapData, 0, 0);
                drawGrid();
                drawRect(lineStartPoint, pos);
            } else if (currentDrawTool === 'arc') {
                if (drawState.clickCount === 1) { 
                    ctx.putImageData(previewMapData, 0, 0);
                    drawGrid();
                    setupLineStyle();
                    ctx.beginPath();
                    ctx.moveTo(drawState.p1.x, drawState.p1.y);
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                } else if (drawState.clickCount === 2) { 
                    ctx.putImageData(previewMapData, 0, 0);
                    drawGrid();
                    drawArc(drawState.p1, drawState.p2, pos); 
                }
            } else if (currentDrawTool === 'triangle') {
                if (drawState.clickCount === 1) { 
                    ctx.putImageData(previewMapData, 0, 0);
                    drawGrid();
                    setupLineStyle();
                    ctx.beginPath();
                    ctx.moveTo(drawState.p1.x, drawState.p1.y);
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                } else if (drawState.clickCount === 2) { 
                    ctx.putImageData(previewMapData, 0, 0);
                    drawGrid();
                    drawTriangle(drawState.p1, drawState.p2, pos); 
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            const pos = getMousePos(e);
            
            if (currentMode === 'place_car') {
                if (isDrawing) {
                    isDrawing = false;
                    initialCarAngle = Math.atan2(pos.y - initialCarY, pos.x - initialCarX);
                    
                    ctx.putImageData(previewMapData, 0, 0);
                    drawGrid();
                    drawCarAtCurrentInitialPosition(); 
                    previewMapData = null;
                }
                return;
            }

            if (currentMode !== 'draw' || !isDrawing) return;

            if (currentDrawTool === 'freehand' || currentDrawTool === 'eraser') {
                isDrawing = false;
                ctx.beginPath(); 
                saveHistory(); 
            } else if (currentDrawTool === 'line') {
                isDrawing = false;
                ctx.putImageData(previewMapData, 0, 0); 
                drawGrid();
                setupLineStyle();
                ctx.beginPath();
                ctx.moveTo(lineStartPoint.x, lineStartPoint.y);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke(); 
                
                resetDrawState();
                saveHistory(); 
            } else if (currentDrawTool === 'rect') {
                isDrawing = false;
                ctx.putImageData(previewMapData, 0, 0); 
                drawGrid();
                drawRect(lineStartPoint, pos);
                
                resetDrawState();
                saveHistory(); 
            }
        });
        
        canvas.addEventListener('mouseleave', () => {
            if (currentMode === 'place_car' && isDrawing) {
                isDrawing = false;
                if (previewMapData) {
                    ctx.putImageData(previewMapData, 0, 0); 
                    drawGrid();
                }
                drawCarAtCurrentInitialPosition(); 
                previewMapData = null;
            }

            if (currentMode !== 'draw') return;
            
            if (isDrawing) {
                isDrawing = false;
                if (previewMapData) {
                    ctx.putImageData(previewMapData, 0, 0);
                    drawGrid();
                }
                resetDrawState();
            }
        });

        // --- KHỞI TẠO ---
        car.speed = parseFloat(carSpeedSlider.value);
        LINE_WIDTH = parseInt(lineWidthSlider.value, 10);
        ERASER_WIDTH = LINE_WIDTH + 2;
        
        setMode('draw'); 
        setDrawTool('freehand'); 
        
        clearCanvas();
        resetHistory();
        redrawAll(true);

    </script>
</body>
</html>

