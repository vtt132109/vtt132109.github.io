<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phân tích Robot Dò Line (V36) - Giao diện Split-View</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Ngăn cuộn body chính */
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        
        pre code {
            display: block;
            background: #1f2937; /* bg-gray-800 */
            color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.875rem;
            line-height: 1.6;
            /* Đặt max-height để cuộn bên trong nếu cần, dù parent đã overflow-y */
            max-height: 90vh; 
        }
        
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            height: 400px;
            max-height: 50vh;
        }
        
        h2 {
            font-size: 1.875rem;
            font-weight: 700;
            margin-bottom: 1rem;
            margin-top: 2rem;
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 0.5rem;
        }
        /* Hiệu ứng cho tiêu đề có thể click */
        h3[onclick] {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            margin-top: 1.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border-radius: 0.375rem;
            padding: 0.5rem;
            margin-left: -0.5rem;
            margin-right: -0.5rem;
        }
        h3[onclick]:hover {
            background-color: #f3f4f6; /* bg-gray-100 */
            color: #2563eb; /* text-blue-600 */
        }

        p, ul, li {
            margin-bottom: 1rem;
            line-height: 1.75;
        }
        ul {
            list-style-type: disc;
            list-style-position: inside;
            padding-left: 1rem;
        }
        code:not(pre code) {
            background-color: #e2e8f0;
            color: #2d3748;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        /* Class highlight cho code */
        .highlight {
            background-color: #fef08a; /* bg-yellow-300 */
            color: #1f2937; /* text-gray-800 */
            border-radius: 3px;
            padding: 2px 0;
            box-shadow: 0 0 10px #fef08a;
            transition: all 0.3s ease;
        }
    </style>
    <!-- Chosen Palette: Subtle Blue and Gray -->
    <!-- Application Structure Plan: 
        Đã thay đổi hoàn toàn cấu trúc từ tab sang Split-View (chia đôi màn hình).
        1. Layout: `flex flex-col md:flex-row` cho 2 pane chính.
        2. Pane Trái: Báo cáo phân tích (`panel-report`). Có `overflow-y-auto` để cuộn độc lập.
        3. Pane Phải: Mã nguồn (`panel-code`). Có `overflow-y-auto` để cuộn độc lập.
        4. Tương tác "Click-to-Guide": Các tiêu đề `h3` trong pane trái có `onclick="scrollToCode('...')`.
        5. JavaScript `scrollToCode`: Hàm này sẽ tìm văn bản (`searchText`) trong `code-content` (pane phải), 
           thay thế nó bằng một `<span class="highlight">` được bọc lại, 
           sử dụng `scrollIntoView()` để cuộn đến đó, 
           và sau 3 giây thì xóa highlight để khôi phục code gốc.
        Lý do: Cấu trúc này trực quan hơn cho việc *phân tích* code, cho phép người dùng xem báo cáo và
        code liên quan ngay bên cạnh nhau thay vì phải chuyển tab.
    -->
    <!-- Visualization & Content Choices:
        1. Report Content: Hiển thị trong pane trái.
        2. Report Logic Chart: Giữ lại (Chart.js), hiển thị trong pane trái.
        3. Code Content: Hiển thị trong pane phải (`<pre><code>`).
        4. (ĐÃ XÓA) Tất cả các tính năng AI (TTS, Gemini text/json/image).
        5. (MỚI) Tương tác Click-to-Scroll: Goal: Liên kết trực tiếp báo cáo với code. Presentation: `h3[onclick]` ở pane trái. Interaction: Kích hoạt JS `scrollToCode()` để highlight và cuộn pane phải. Justification: Đây là yêu cầu cốt lõi của người dùng để làm cho việc phân tích trực quan hơn.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
</head>
<body class="bg-gray-50 text-gray-800 flex flex-col h-screen antialiased">

    <!-- HEADER -->
    <header class="text-center py-6 bg-white shadow-md z-20">
        <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Phân tích Robot Dò Line (V36)</h1>
        <p class="text-md text-gray-600 mt-1">Giao diện Phân tích Code Tương tác (Split-Screen)</p>
    </header>

    <!-- MAIN CONTENT (Split Screen) -->
    <main class="flex-1 flex flex-col md:flex-row overflow-hidden">
        
        <!-- === PANE TRÁI: BÁO CÁO PHÂN TÍCH === -->
        <div id="panel-report" class="md:w-1/2 h-full overflow-y-auto p-6 md:p-10 bg-white shadow-lg z-10 border-r border-gray-200">
            <section id="bao-cao">
                <h1 class="text-3xl font-bold mb-6 text-gray-900">Báo cáo Phân tích Code: Xe Dò Line (V36)</h1>
                <p>Tài liệu này giải thích chi tiết toàn bộ mã nguồn của file <code>LineFollower_V36.ino</code>. Bấm vào các tiêu đề <code>h3</code> bên dưới để tự động cuộn đến phần code tương ứng ở bên phải.</p>

                <h2 onclick="scrollToCode('MỤC TIÊU CỦA DỰ ÁN')" class="cursor-pointer hover:text-blue-600">PHẦN 1: TỔNG QUAN VÀ CẤU TRÚC</h2>

                <h3 onclick="scrollToCode('MỤC TIÊU CỦA DỰ ÁN')">1.1. Mục tiêu của Dự án</h3>
                <p>Mã nguồn này điều khiển một robot 4 bánh (sử dụng 2 cầu H trong shield AFMotor) với hai chức năng chính:</p>
                <ul>
                    <li><strong>Dò line (Line Following):</strong> Tự động đi theo một vạch đen trên nền trắng.</li>
                    <li><strong>Tránh vật cản (Obstacle Avoidance):</strong> Sử dụng cảm biến siêu âm gắn trên một động cơ servo. Khi phát hiện vật cản, robot sẽ dừng, quét servo để tìm không gian trống (trái hoặc phải) và thực hiện một động tác rẽ chữ U để vòng qua vật cản.</li>
                </ul>

                <h3 onclick="scrollToCode('LOGIC NỔI BẬT')">1.2. Các Logic Nổi bật (Phiên bản V36)</h3>
                <p>Đây là phiên bản đã trải qua nhiều cải tiến, với các logic quan trọng:</p>
                <ul>
                    <li><strong>PID Thích ứng (Adaptive PID):</strong> Tự động thay đổi hệ số <code>Kp</code> (hệ số P) dựa trên độ ổn định của robot. Nếu robot chạy thẳng và ổn định, nó sẽ tăng tốc và giảm <code>Kp</code>. Nếu robot mất ổn định (vào cua), nó sẽ giảm tốc và tăng <code>Kp</code> để bám đường tốt hơn.</li>
                    <li><strong>Grace Period (10 giây đầu):</strong> Trong 10 giây đầu tiên, robot chỉ dùng 2 cảm biến giữa (S2, S3) để dò line PID đơn thuần. Tất cả các logic rẽ (ngã tư, cua gắt) dùng S1 và S4 đều bị vô hiệu hóa. Điều này giúp robot khởi động ổn định.</li>
                    <li><strong>Xử lý Ngã rẽ Thông minh (V34 Logic):</strong> Hàm <code>performTurn()</code> (thực hiện rẽ) được thiết kế để không bị "lừa" ở ngã ba tam giác. Khi rẽ phải, nó tìm trạng thái <code>xx10</code> (S3 thấy line, S4 không thấy). Khi rẽ trái, nó tìm <code>01xx</code> (S2 thấy line, S1 không thấy).</li>
                    <li><strong>Xử lý Mất Line Thông minh (V30 Logic):</strong> Khi mất line (<code>0000</code>), robot không dừng lại. Nó sẽ cố gắng tìm line trong 500ms, và nếu vẫn không thấy, nó sẽ chuyển sang chế độ "xoay tròn tại chỗ" để tích cực tìm kiếm thay vì "bỏ cuộc".</li>
                    <li><strong>Xử lý Trường hợp Đặc biệt (V35 Logic):</strong> Thêm một trường hợp ưu tiên <code>1001</code> (S1 và S4 cùng thấy line), thường xảy ra ở ngã ba hẹp, và ưu tiên rẽ trái.</li>
                </ul>

                <h2 onclick="scrollToCode('PHÂN TÍCH CÁC KHỐI CODE')" class="cursor-pointer hover:text-blue-600">PHẦN 2: PHÂN TÍCH CÁC KHỐI CODE</h2>

                <h3 onclick="scrollToCode('Thư viện và Cấu hình')">2.1. Thư viện và Cấu hình (Defines & Globals)</h3>
                <ul>
                    <li><strong>Thư viện:</strong> <code>&lt;AFMotor.h&gt;</code> (điều khiển động cơ), <code>&lt;Servo.h&gt;</code> (điều khiển servo).</li>
                    <li><strong>Hằng số Cấu hình:</strong>
                        <ul>
                            <li><code>MIN_PWM 80</code>: Ngưỡng PWM tối thiểu để động cơ khởi động.</li>
                            <li><code>LEFT_OFFSET</code>, <code>RIGHT_OFFSET</code>: Hệ số hiệu chỉnh tốc độ 2 bên để robot đi thẳng.</li>
                            <li><code>LOST_LINE_TIMEOUT 500</code>: Thời gian (ms) robot cố gắng tìm line trước khi xoay tại chỗ.</li>
                            <li><code>INITIAL_GRACE_PERIOD 10000</code>: 10 giây đầu khởi động chỉ dùng 2 cảm biến giữa.</li>
                            <li><code>SCAN_LEFT 160</code>, <code>SCAN_CENTER 90</code>, <code>SCAN_RIGHT 20</code>: Các góc quét servo.</li>
                            <li><code>OBSTACLE_DISTANCE 15</code>: Khoảng cách (cm) kích hoạt tránh vật cản.</li>
                        </ul>
                    </li>
                    <li><strong>Biến Toàn cục:</strong>
                        <ul>
                            <li><code>SENSOR_MIN_CALI</code>, <code>SENSOR_MAX_CALI</code>: Lưu giá trị hiệu chỉnh (trắng/đen) của cảm biến.</li>
                            <li><code>threshold_for_turn</code>: Ngưỡng để quyết định là "thấy line đen".</li>
                            <li><code>sens[]</code>: Mảng 4 pin cảm biến (S1-S4).</li>
                            <li><strong>Biến PID:</strong> <code>error</code>, <code>P</code>, <code>I</code>, <code>D</code>, <code>previous_error</code>, <code>pre_pos</code>.</li>
                            <li><strong>Biến Trạng thái:</strong> <code>isTurning</code>, <code>isAvoidingObstacle</code>.</li>
                            <li><code>programStartTime</code>: Lưu thời điểm bắt đầu để tính "Grace Period".</li>
                        </ul>
                    </li>
                </ul>

                <h3 onclick="scrollToCode('CÁC HÀM ĐIỀU KHIỂN ĐỘNG CƠ')">2.2. Các hàm Điều khiển Động cơ</h3>
                <p><code>setLeftMotors(int speed)</code> và <code>setRightMotors(int speed)</code>:</p>
                <p>Các hàm này không chỉ đặt tốc độ. Chúng thực hiện 3 logic:
                    1. Áp dụng hệ số <code>OFFSET</code> để cân bằng tốc độ hai bên.
                    2. Kiểm tra <code>MIN_PWM</code>: Nếu tốc độ yêu cầu quá thấp, hàm sẽ dừng động cơ (<code>speed = 0</code>) để tránh "ì".
                    3. Quyết định <code>FORWARD</code>, <code>BACKWARD</code>, hoặc <code>RELEASE</code> (thả nổi) dựa trên giá trị <code>speed</code> cuối cùng.
                </p>

                <h3 onclick="scrollToCode('CÁC HÀM CẢM BIẾN VÀ LOGIC')">2.3. Các hàm Cảm biến và Logic Phụ</h3>
                <ul>
                    <li onclick="scrollToCode('manual_calibration()')"><code>manual_calibration()</code>: Chạy 5 giây trong <code>setup()</code>, lia robot qua vạch đen và nền trắng để tìm giá trị <code>SENSOR_MIN_CALI</code> và <code>SENSOR_MAX_CALI</code>, từ đó tính ra <code>threshold_for_turn</code>.</li>
                    <li onclick="scrollToCode('checkUltrasonicDistance()')"><code>checkUltrasonicDistance()</code>: Phát xung và đo thời gian phản hồi của cảm biến siêu âm, trả về khoảng cách (cm). Trả về <code>999.0</code> nếu bị timeout.</li>
                    <li onclick="scrollToCode('scanSurroundings()')"><code>scanSurroundings()</code>: Được gọi khi gặp vật cản. Servo quét trái (đo <code>distLeft</code>) và quét phải (đo <code>distRight</code>), sau đó quay về giữa. Trả về <code>true</code> (rẽ phải) nếu bên phải thoáng hơn, ngược lại trả về <code>false</code> (rẽ trái).</li>
                    <li onclick="scrollToCode('performAvoidance()')"><code>performAvoidance()</code>: Một "Máy Trạng Thái" (State Machine) điều khiển robot thực hiện 4 bước rẽ chữ U: (1) Quay 90 độ, (2) Đi thẳng, (3) Quay 90 độ ngược lại, (4) Đi thẳng tìm line.</li>
                    <li onclick="scrollToCode('performTurn()')"><code>performTurn()</code>: Hàm này được gọi liên tục khi <code>isTurning = true</code>. Nó rất thông minh:
                        <ul>
                            <li>Khi rẽ phải, nó chỉ dừng khi thấy <code>s3 && !s4</code> (trạng thái <code>xx10</code>).</li>
                            <li>Khi rẽ trái, nó chỉ dừng khi thấy <code>s2 && !s1</code> (trạng thái <code>01xx</code>).</li>
                        </ul>
                    </li>
                </ul>
                
                <hr class="my-8">

                <section id="visualization">
                    <h2 class="text-3xl font-bold mb-6 text-gray-900">Trực quan hóa Logic Dò Line</h2>
                    <p class="mb-6">Hàm <code>linetracingMode()</code> là trái tim của robot. Biểu đồ dưới đây tóm tắt các nhóm logic chính mà robot xử lý (không bao gồm "Grace Period").</p>
                    
                    <div class="chart-container">
                        <canvas id="logicCasesChart"></canvas>
                    </div>
                    <p class="text-center text-sm text-gray-600 mt-2">Biểu đồ thể hiện các nhóm logic trong hàm <code>linetracingMode()</code></p>
                </section>
                
                <hr class="my-8">

                <h2 onclick="scrollToCode('linetracingMode()')" class="cursor-pointer hover:text-blue-600">PHẦN 3: HÀM `linetracingMode()` (TRÁI TIM CỦA ROBOT)</h2>
                <p>Đây là hàm phức tạp nhất. Nó quyết định robot làm gì khi không bận (không <code>isTurning</code> hoặc <code>isAvoidingObstacle</code>).</p>
                <ol class="list-decimal list-inside space-y-2">
                    <li><strong>Đọc và Chuẩn hóa Cảm biến:</strong> Đọc giá trị 0-1023, chuẩn hóa về 0.0-1.0 (<code>eachError[]</code>), sau đó chuyển sang <code>bool</code> (true/false).</li>
                    <li onclick="scrollToCode('Logic &quot;Grace Period&quot;')"><strong>Logic "Grace Period" (V35):</strong> Nếu đang trong 10 giây đầu, ép <code>s1 = false</code> và <code>s4 = false</code>, vô hiệu hóa tất cả các logic rẽ.</li>
                    <li><strong>Hệ thống Phân loại (Các CASE - Sắp xếp theo thứ tự ưu tiên):</strong>
                        <ul>
                            <li onclick="scrollToCode('CASE 1.5')"><code>CASE 1.5 (1001)</code>: (Sau 10s) Ưu tiên rẽ trái. <strong>Ưu tiên cao nhất.</strong></li>
                            <li onclick="scrollToCode('CASE 2')"><code>CASE 2 (1111)</code>: (Sau 10s) Ngã tư. Kích hoạt <code>performTurn()</code> (rẽ phải).</li>
                            <li onclick="scrollToCode('CASE 3A')"><code>CASE 3A (1110) / 3B (0111)</code>: (Sau 10s) Cua gắt/Ngã rẽ. Kích hoạt <code>performTurn()</code> (trái/phải).</li>
                            <li onclick="scrollToCode('CASE 4A')"><code>CASE 4A (0100) / 4B (0010)</code>: Line hơi lệch. Chỉnh nhẹ.</li>
                            <li onclick="scrollToCode('CASE 4C')"><code>CASE 4C (1000) / 4D (0001)</code>: (Sau 10s) Line lệch hẳn ra ngoài. Xoay tại chỗ (-200/200) để tìm.</li>
                            <li onclick="scrollToCode('CASE 5')"><code>CASE 5 (0000)</code>: Mất line. Cố gắng tìm trong 500ms, sau đó xoay tròn tại chỗ.</li>
                            <li onclick="scrollToCode('CASE 6')"><code>CASE 6 (Else)</code>: <strong>Dò line PID (Trường hợp bình thường).</strong>
                                <ul>
                                    <li><strong>PID (Grace Period):</strong> Trong 10s đầu, <code>pos_pid</code> chỉ được tính bằng S2 và S3.</li>
                                    <li><strong>PID (Thích ứng Kp):</strong> Nếu <code>stabilityCounter > 20</code> (ổn định), robot chạy nhanh hơn (tốc độ 240) và <code>Kp</code> thấp (40.0). Ngược lại, robot chạy chậm hơn (210) và <code>Kp</code> cao (100.0).</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ol>

                <h2 onclick="scrollToCode('HÀM SETUP VÀ LOOP CHÍNH')" class="cursor-pointer hover:text-blue-600">PHẦN 4: VÒNG LẶP CHÍNH (`setup()` và `loop()`)</h2>
                <ul>
                    <li onclick="scrollToCode('void setup()')"><code>setup()</code>:
                        <ol class="list-decimal list-inside ml-4">
                            <li>Khởi tạo <code>Serial</code>, <code>pinMode</code>, <code>Servo</code>.</li>
                            <li><strong>Chạy <code>manual_calibration()</code></strong> (rất quan trọng).</li>
                            <li><strong>Gán <code>programStartTime = millis()</code></strong> (bắt đầu đếm 10 giây).</li>
                            <li>Gán <code>robotState = 1</code> (Tự động BẬT).</li>
                        </ol>
                    </li>
                    <li onclick="scrollToCode('void loop()')"><code>loop()</code>: Đây là "bộ não" quyết định thứ tự ưu tiên:
                        <ol class="list-decimal list-inside ml-4">
                            <li><strong>Ưu tiên 1:</strong> <code>isAvoidingObstacle</code>? Nếu <code>true</code>, chạy <code>performAvoidance()</code> và <code>return</code>.</li>
                            <li><strong>Ưu tiên 2:</strong> <code>robotState == 0</code>? Nếu <code>true</code>, dừng robot và <code>return</code>.</li>
                            <li><strong>Ưu tiên 3:</strong> Kiểm tra vật cản. Nếu có VÀ robot rảnh, bắt đầu quy trình tránh.</li>
                            <li><strong>Ưu tiên 4:</strong> Nếu không có gì ở trên, chạy <code>linetracingMode()</code>.</li>
                        </ol>
                    </li>
                </ul>
            </section>
        </div>
        
        <!-- === PANE PHẢI: MÃ NGUỒN === -->
        <div id="panel-code" class="md:w-1/2 h-full overflow-y-auto p-6 md:p-10 bg-gray-900 text-gray-300">
            <div class="relative">
                <button onclick="copyCode()" id="copy-btn" class="absolute top-4 right-4 bg-gray-700 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-200 z-10">
                    Sao chép Mã
                </button>
                <pre><code id="code-content">/*
 * =================================================================================
 * TÊN DỰ ÁN: XE DÒ LINE SIÊU ÂM (V36 - ĐỌN GIẢN COMMENT)
 * /* --- TARGET: MỤC TIÊU CỦA DỰ ÁN --- */
 * MÔ TẢ:
 * Dựa trên V35.
 *
 * /* --- TARGET: LOGIC NỔI BẬT --- */
 * --- LOGIC NỔI BẬT (TỪ V35) ---
 * 1. MỤC TIÊU:
 * a. Thêm chế độ "Grace Period" (Ân xá): 10 giây đầu tiên chỉ dò line
 * bằng 2 cảm biến giữa (S2, S3), bỏ qua mọi trường hợp rẽ.
 * b. Thêm trường hợp đặc biệt `1001` (S1 và S4 cùng thấy line) thì
 * ưu tiên rẽ TRÁI.
 *
 * 2. LOGIC "GRACE PERIOD":
 * - 10 giây đầu (`INITIAL_GRACE_PERIOD`).
 * - Tự động gán `s1 = false` và `s4 = false`. (Vô hiệu hóa các CASE rẽ).
 * - `CASE 6 (PID)` CHỈ tính toán `pos_pid` dựa trên S2 và S3.
 *
 * 3. CASE 1.5 (1001):
 * - Sau 10 giây, nếu gặp `1001`, robot sẽ thực hiện cú xoay TRÁI mạnh.
 *
 * 4. LOGIC KHÁC (TỪ V34):
 * - `performTurn()` thông minh (kiểm tra `xx10` và `01xx`).
 * - Quét Servo siêu âm tránh vật cản.
 *
 * --- KẾT NỐI PHẦN CỨNG ---
 * (Giữ nguyên)
 * =================================================================================
 */

/* --- TARGET: Thư viện và Cấu hình --- */
// --- THƯ VIỆN ---
#include &lt;AFMotor.h&gt;
#include &lt;Servo.h&gt;

// --- CẤU HÌNH VÀ PIN ---
const bool DEBUG_PRINT = 1;

// --- CẤU HÌNH MOTOR ---
#define MIN_PWM 80
const float LEFT_OFFSET = 1.0;
const float RIGHT_OFFSET = 0.9;

// --- CẤU HÌNH KHÁC ---
#define LOST_LINE_TIMEOUT 500 // Giữ 500ms

// Thời gian ân xá: 10 giây đầu chỉ chạy PID 2 cảm biến
#define INITIAL_GRACE_PERIOD 10000 // 10 giây (10000 ms)

// Cấu hình quét Servo siêu âm
#define SCAN_LEFT 160
#define SCAN_CENTER 90
#define SCAN_RIGHT 20
#define SCAN_DELAY 300

// Cấu hình tránh vật cản
#define OBSTACLE_DISTANCE 15
#define TURN_SPEED 180
#define AVOID_SPEED 150
#define SEARCH_SPEED 130
#define TURN_DURATION 600
#define STRAIGHT_DURATION 1000
#define SEARCH_TIMEOUT 3000


// ================================================================================
// Biến lưu giá trị hiệu chỉnh
int SENSOR_MIN_CALI = 1023;
int SENSOR_MAX_CALI = 0;
int threshold_for_turn = 500;
// ================================================================================

// Cảm biến
#define ULTRA_TRIG_PIN A0
#define ULTRA_ECHO_PIN A1

// Servo (Giờ dùng cho siêu âm)
#define SERVO_PIN 9
Servo myServo;

// Cảm biến dò line
uint8_t sens[] = {A2, A3, A4, A5}; // S1, S2, S3, S4

// PID
const float Ki = 0.01;
const float Kd = 10.0;
float error = 0, P = 0, I = 0, D = 0, PID_value = 0;
float previous_error = 0, previous_I = 0;
float pre_pos = 1500.0;

// Biến trạng thái
int robotState = 0;
int stabilityCounter = 0;
unsigned long lostLineStartTime = 0;
bool isTurning = false;
unsigned long turnStartTime = 0;
bool turningRight = false;
int currentTurnSpeed = 0;
unsigned long currentMaxTurnTime = 0;

// Thời điểm bắt đầu chương trình (cho Grace Period)
unsigned long programStartTime = 0;

// Trạng thái tránh vật cản
bool isAvoidingObstacle = false;
int avoidState = 0;
unsigned long avoidStartTime = 0;
bool avoidTurnRight = false;

// --- KHỞI TẠO ĐỐI TƯỢNG ĐỘNG CƠ ---
AF_DCMotor motorLeftFront(1);
AF_DCMotor motorLeftRear(2);
AF_DCMotor motorRightFront(3);
AF_DCMotor motorRightRear(4);

/*
 * =================================================================================
 * /* --- TARGET: CÁC HÀM ĐIỀU KHIỂN ĐỘNG CƠ --- */
 * CÁC HÀM ĐIỀU KHIỂN ĐỘNG CƠ
 * =================================================================================
 */

// Hàm điều khiển 2 động cơ TRÁI (Áp dụng offset và min_pwm)
void setLeftMotors(int speed) {
  speed = constrain(speed * LEFT_OFFSET, -255, 255);

  if (speed > 0 && speed < MIN_PWM) {
    speed = 0;
  } else if (speed < 0 && speed > -MIN_PWM) {
    speed = 0;
  }

  if (speed == 0) {
      motorLeftFront.run(RELEASE);
      motorLeftRear.run(RELEASE);
  } else if (speed > 0) {
    motorLeftFront.run(FORWARD);
    motorLeftRear.run(FORWARD);
    motorLeftFront.setSpeed(speed);
    motorLeftRear.setSpeed(speed);
  } else {
    motorLeftFront.run(BACKWARD);
    motorLeftRear.run(BACKWARD);
    motorLeftFront.setSpeed(abs(speed));
    motorLeftRear.setSpeed(abs(speed));
  }
}

// Hàm điều khiển 2 động cơ PHẢI (Áp dụng offset và min_pwm)
void setRightMotors(int speed) {
    speed = constrain(speed * RIGHT_OFFSET, -255, 255);

    if (speed > 0 && speed < MIN_PWM) {
     speed = 0;
    } else if (speed < 0 && speed > -MIN_PWM) {
     speed = 0;
    }

    if (speed == 0) {
      motorRightFront.run(RELEASE);
      motorRightRear.run(RELEASE);
    } else if (speed > 0) {
     motorRightFront.run(FORWARD);
     motorRightRear.run(FORWARD);
     motorRightFront.setSpeed(speed);
     motorRightRear.setSpeed(speed);
    } else {
     motorRightFront.run(BACKWARD);
     motorRightRear.run(BACKWARD);
     motorRightFront.setSpeed(abs(speed));
     motorRightRear.setSpeed(abs(speed));
    }
}

// Hàm dừng tất cả động cơ (KHÔNG điều khiển LED)
void stopMotors() {
  motorLeftFront.run(RELEASE);
  motorLeftRear.run(RELEASE);
  motorRightFront.run(RELEASE);
  motorRightRear.run(RELEASE);
}

  // Hàm dừng động cơ và xử lý LED
  void stopMotorsAndLed() {
     stopMotors();
     digitalWrite(LED_BUILTIN, LOW);
  }


/*
 * =================================================================================
 * /* --- TARGET: CÁC HÀM CẢM BIẾN VÀ LOGIC --- */
 * CÁC HÀM CẢM BIẾN VÀ LOGIC
 * =================================================================================
 */

// 1. Tự động hiệu chỉnh
void manual_calibration() {
  digitalWrite(LED_BUILTIN, HIGH);
  Serial.println(F("Bat dau hieu chinh line. Lia robot qua vach DEN va TRANG trong 5 giay..."));
  unsigned long startTime = millis();
  SENSOR_MIN_CALI = 1023; SENSOR_MAX_CALI = 0;
  while (millis() - startTime < 5000) {
    for (int j = 0; j < 4; j++) {
      int val = analogRead(sens[j]);
      if (val > SENSOR_MAX_CALI) SENSOR_MAX_CALI = val;
      if (val < SENSOR_MIN_CALI) SENSOR_MIN_CALI = val;
    }
    delay(20);
  }
  digitalWrite(LED_BUILTIN, LOW);
  threshold_for_turn = (SENSOR_MAX_CALI + SENSOR_MIN_CALI) / 2;
  Serial.println(F("--- Hieu chinh xong! ---"));
  Serial.print(F("SENSOR_MIN (Trang) tim thay: ")); Serial.println(SENSOR_MIN_CALI);
  Serial.print(F("SENSOR_MAX (Den) tim thay: ")); Serial.println(SENSOR_MAX_CALI);
  Serial.print(F("Nguong re (threshold) tinh duoc: ")); Serial.println(threshold_for_turn);
}

// Hàm thực hiện và kiểm tra hoàn thành cú xoay MẠNH (Thông minh)
void performTurn() {
  // 1. Tiếp tục xoay
  if (turningRight) { setLeftMotors(currentTurnSpeed); setRightMotors(-currentTurnSpeed); }
  else { setLeftMotors(-currentTurnSpeed); setRightMotors(currentTurnSpeed); }

  // 2. Đọc 4 cảm biến để tìm line MỘT CÁCH CHÍNH XÁC
  bool s1 = (analogRead(sens[0]) > threshold_for_turn);
  bool s2 = (analogRead(sens[1]) > threshold_for_turn);
  bool s3 = (analogRead(sens[2]) > threshold_for_turn);
  bool s4 = (analogRead(sens[3]) > threshold_for_turn);

  bool lineFound = false;
  
  if (turningRight) {
      // Đang rẽ PHẢI, mục tiêu là tìm xx10
      // Dừng khi S3=1 VÀ S4=0 (để tránh 0011 ở ngã ba)
      if (s3 && !s4) {
          lineFound = true;
          if (DEBUG_PRINT) Serial.println(F(" -> Re PHAI tim thay line (S3=1, S4=0)."));
      }
  } else {
      // Đang rẽ TRÁI, mục tiêu là tìm 01xx
      // Dừng khi S2=1 VÀ S1=0 (để tránh 1100 ở ngã ba)
      if (s2 && !s1) {
          lineFound = true;
          if (DEBUG_PRINT) Serial.println(F(" -> Re TRAI tim thay line (S2=1, S1=0)."));
      }
  }

  // 3. Kiểm tra timeout
  if (millis() - turnStartTime > currentMaxTurnTime) {
      if (DEBUG_PRINT) Serial.println(F(" -> Timeout! Dung xoay.")); lineFound = true;
  }

  // 4. Hoàn thành xoay
  if (lineFound) {
       stopMotorsAndLed(); // Dừng 1 chút
       delay(50);
       previous_error = 0; previous_I = 0; pre_pos = 1500.0;
       isTurning = false; // Tắt trạng thái xoay
  }
}

// 2. Logic dò line chính
void linetracingMode() {

  // --- ƯU TIÊN 1: Đang xoay
  if (isTurning) { performTurn(); return; }

  // --- C. ĐỌC CẢM BIẾN VÀ XỬ LÝ BÌNH THƯỜNG ---
  float eachError[4]; float sumError_all = 0; float see_line_threshold = 0.7;
  if (DEBUG_PRINT) Serial.print(F("Line (Raw): "));
  for (int i = 0; i < 4; i++) { int val = analogRead(sens[i]); if (DEBUG_PRINT) { Serial.print(val); Serial.print(" "); }
    eachError[i] = constrain((1.0 * (val - SENSOR_MIN_CALI)) / (1.0 * (SENSOR_MAX_CALI - SENSOR_MIN_CALI)), 0.0, 1.0); sumError_all += eachError[i]; }
  
  /* --- TARGET: Logic "Grace Period" --- */
  // Logic "Grace Period" (Ân xá 10 giây đầu)
  unsigned long currentTime = millis();
  bool isGracePeriod = (currentTime - programStartTime < INITIAL_GRACE_PERIOD);

  // Đọc giá trị bool thô
  bool s1_raw = (eachError[0] > see_line_threshold);
  bool s2_raw = (eachError[1] > see_line_threshold);
  bool s3_raw = (eachError[2] > see_line_threshold);
  bool s4_raw = (eachError[3] > see_line_threshold);

  bool s1, s2, s3, s4; // Biến s# cuối cùng để dùng cho các CASE

  if (isGracePeriod) {
    if (DEBUG_PRINT) Serial.print(F(" (Grace Period) "));
    s1 = false; // Tắt S1
    s2 = s2_raw;
    s3 = s3_raw;
    s4 = false; // Tắt S4
  } else {
    // Sau 10s, dùng tất cả cảm biến
    s1 = s1_raw;
    s2 = s2_raw;
    s3 = s3_raw;
    s4 = s4_raw;
  }

  // --- D. LIỆT KÊ CÁC TRƯỜNG HỢP ---

  /* --- TARGET: CASE 1.5 --- */
  // CASE 1.5: Ưu tiên rẽ trái khi thấy 1001 (Chỉ chạy sau 10s)
  if (s1 && !s2 && !s3 && s4) {
    lostLineStartTime = 0;
    if (!isTurning) {
        if (DEBUG_PRINT) Serial.println(F(" | CASE 1.5 (1001): Uu tien RE TRAI."));
        stabilityCounter = 0;
        isTurning = true;
        turnStartTime = millis();
        turningRight = false; // Rẽ TRÁI
        currentTurnSpeed = 220;
        currentMaxTurnTime = 1200;
        performTurn();
    }
    return; // Rất quan trọng
  }

  /* --- TARGET: CASE 2 --- */
  // CASE 2: NGÃ TƯ (1111) -> Rẽ Phải 90 độ (Tự động tắt trong 10s)
  if (s1 && s2 && s3 && s4) {
    lostLineStartTime = 0; if (DEBUG_PRINT) Serial.println(F(" | CASE 2: NGA TU (1111)! Bat dau RE PHAI 90 DO.")); stabilityCounter = 0;
    isTurning = true; turnStartTime = millis(); turningRight = true; currentTurnSpeed = 220; currentMaxTurnTime = 1500; performTurn(); return;
  }
  /* --- TARGET: CASE 3A --- */
  // CASE 3A: CUA GẮT TRÁI (1110) (Tự động tắt trong 10s)
  else if (s1 && s2 && s3 && !s4) {
    lostLineStartTime = 0;
    if (!isTurning) {
      if (DEBUG_PRINT) Serial.println(F(" | CASE 3A: CUA GAT TRAI (1110)! Bat dau XOAY TRAI MANH."));
      stabilityCounter = 0;
      isTurning = true;
      turnStartTime = millis();
      turningRight = false; 
      currentTurnSpeed = 220; 
      currentMaxTurnTime = 1200; 
      performTurn(); 
    } else if (DEBUG_PRINT) {
      Serial.println(F(" | CASE 3A: Ignored (already turning)."));
    }
    return; 
  }
  // CASE 3B: CUA GẮT PHẢI (0111) (Tự động tắt trong 10s)
  else if (!s1 && s2 && s3 && s4) {
    lostLineStartTime = 0;
    if (!isTurning) { 
      if (DEBUG_PRINT) Serial.println(F(" | CASE 3B: CUA GAT PHAI (0111)! Bat dau XOAY PHAI MANH."));
      stabilityCounter = 0;
      isTurning = true;
      turnStartTime = millis();
      turningRight = true; 
      currentTurnSpeed = 220; 
      currentMaxTurnTime = 1200; 
      performTurn(); 
    } else if (DEBUG_PRINT) {
      Serial.println(F(" | CASE 3B: Ignored (already turning)."));
    }
    return; 
  }
  /* --- TARGET: CASE 4A --- */
  // CASE 4A: PHỤC HỒI CUA TRÁI (0100) (Hoạt động bình thường)
  else if (!s1 && s2 && !s3 && !s4) {
      lostLineStartTime = 0; if (DEBUG_PRINT) Serial.println(F(" | CASE 4A: PHUC HOI TRAI (0100)! Re trai nhe...")); stabilityCounter = 0;
      setLeftMotors(-100); setRightMotors(180); previous_error = -0.8;
  }
  // CASE 4B: PHỤC HỒI CUA PHẢI (0010) (Hoạt động bình thường)
  else if (!s1 && !s2 && s3 && !s4) {
      lostLineStartTime = 0; if (DEBUG_PRINT) Serial.println(F(" | CASE 4B: PHUC HOI PHAI (0010)! Re phai nhe...")); stabilityCounter = 0;
      setLeftMotors(180); setRightMotors(-100); previous_error = 0.8;
  }
  /* --- TARGET: CASE 4C --- */
  // CASE 4C: PHỤC HỒI CUA TRÁI CỰC GẮT (1000) (Tự động tắt trong 10s)
  else if (s1 && !s2 && !s3 && !s4) {
    lostLineStartTime = 0; if (DEBUG_PRINT) Serial.println(F(" | CASE 4C: PHUC HOI TRAI (1000)! Re trai GAT (Xoay)...")); stabilityCounter = 0;
    setLeftMotors(-200); 
    setRightMotors(200);
    previous_error = -1.5; 
  }
  // CASE 4D: PHỤC HỒI CUA PHẢI CỰC GẮT (0001) (Tự động tắt trong 10s)
  else if (!s1 && !s2 && !s3 && s4) {
    lostLineStartTime = 0; if (DEBUG_PRINT) Serial.println(F(" | CASE 4D: PHUC HOI PHAI (0001)! Re phai GAT (Xoay)...")); stabilityCounter = 0;
    setLeftMotors(200); 
    setRightMotors(-200);
    previous_error = 1.5; 
  }
  /* --- TARGET: CASE 5 --- */
  // CASE 5: MẤT LINE (0000) (Hoạt động bình thường, sẽ kích hoạt khi !s2 && !s3)
  else if (!s1 && !s2 && !s3 && !s4) {
    stabilityCounter = 0;
    if (lostLineStartTime == 0) {
      lostLineStartTime = millis(); if (DEBUG_PRINT) Serial.print(F(" | CASE 5: VUA MAT LINE (0000)! Bat dau timeout..."));
    }

    if (millis() - lostLineStartTime > LOST_LINE_TIMEOUT) {
      if (DEBUG_PRINT) Serial.println(F(" -> HET TIMEOUT! Chuyen sang TIM KIEM XOAY TRON."));
      int searchTurnSpeed = 160;
      if (previous_error < -0.5) { 
        if (DEBUG_PRINT) Serial.println(F(" (Xoay TRAI tim)"));
        setLeftMotors(-searchTurnSpeed); setRightMotors(searchTurnSpeed);
      } else if (previous_error > 0.5) {
        if (DEBUG_PRINT) Serial.println(F(" (Xoay PHAI tim)"));
        setLeftMotors(searchTurnSpeed); setRightMotors(-searchTurnSpeed);
      } else {
        if (DEBUG_PRINT) Serial.println(F(" (Khong ro huong, xoay PHAI)"));
        setLeftMotors(searchTurnSpeed); setRightMotors(-searchTurnSpeed);
      }
    } else {
      if (DEBUG_PRINT) Serial.print(F(" -> Dang timeout, chay theo huong cu...")); int recoverySpeed = 150;
      if (previous_error < -0.5) { if (DEBUG_PRINT) Serial.println(F(" (Re trai tim)")); setLeftMotors(-recoverySpeed / 2); setRightMotors(recoverySpeed); }
      else if (previous_error > 0.5) { if (DEBUG_PRINT) Serial.println(F(" (Re phai tim)")); setLeftMotors(recoverySpeed); setRightMotors(-recoverySpeed / 2); }
      else { if (DEBUG_PRINT) Serial.println(F(" (Di thang tim)")); setLeftMotors(recoverySpeed); setRightMotors(recoverySpeed); }
    }
  }
  /* --- TARGET: CASE 6 --- */
  // CASE 6: BÌNH THƯỜNG - PID
  else {
    lostLineStartTime = 0; // Reset timer mất line vì đang thấy line
    float pos_pid = 0.0;
    
    // Tính PID dựa trên grace period
    if (isGracePeriod) {
        // Chỉ dùng S2 và S3, trọng số 1000 và 2000
        float sumError_pid = 0.0; 
        pos_pid += eachError[1] * 1000.0;
        pos_pid += eachError[2] * 2000.0;
        sumError_pid = eachError[1] + eachError[2];
        if (sumError_pid < 0.01) pos_pid = 1500.0; // Nếu không thấy S2, S3, giả định ở giữa
        else pos_pid /= sumError_pid;
        pre_pos = pos_pid; // Vẫn cập nhật pre_pos
    } else {
        // Dùng cả 4 cảm biến
        pos_pid += eachError[0] * 0.0;
        pos_pid += eachError[1] * 1000.0;
        pos_pid += eachError[2] * 2000.0;
        pos_pid += eachError[3] * 3000.0;
        if (sumError_all < 0.01) pos_pid = pre_pos; 
        else pos_pid /= sumError_all; 
        pre_pos = pos_pid;
    }

    // Cập nhật stabilityCounter
    if (pos_pid > 1100 && pos_pid < 1900) stabilityCounter++; else stabilityCounter = 0;
    
    // Chọn bộ PID Thích ứng
    float current_initSpeed, current_Kp;
    if (stabilityCounter > 20) { if (DEBUG_PRINT) Serial.print(F(" (Stable - Kp THAP) ")); current_initSpeed = 240; current_Kp = 40.0; }
    else { if (DEBUG_PRINT) Serial.print(F(" (Unstable - Kp CAO) ")); current_initSpeed = 210; current_Kp = 100.0; }
    
    // Tính PID
    error = (pos_pid - 1500.0) / 500.0; P = error; I = I + previous_I; I = constrain(I, -100.0, 100.0); D = error - previous_error;
    PID_value = (current_Kp * P) + (Ki * I) + (Kd * D); previous_I = I; previous_error = error;
    
    // Tính tốc độ động cơ
    int left_motor_speed = constrain(current_initSpeed + PID_value, -255, 255); int right_motor_speed = constrain(current_initSpeed - PID_value, -255, 255);
    
    // Điều khiển động cơ
    setLeftMotors(left_motor_speed); setRightMotors(right_motor_speed);
    
    // In debug
    if (DEBUG_PRINT) { Serial.print(F(" | CASE 6: PID | Pos: ")); Serial.print(pos_pid); Serial.print(F(" | Err: ")); Serial.print(error);
      Serial.print(F(" | PID: ")); Serial.print(PID_value); Serial.print(F(" | L/R: ")); Serial.print(left_motor_speed); Serial.print(F("/")); Serial.println(right_motor_speed); }
  }
} // Kết thúc hàm linetracingMode


// 3. Kiểm tra cảm biến siêu âm
float checkUltrasonicDistance() {
  digitalWrite(ULTRA_TRIG_PIN, LOW); delayMicroseconds(2);
  digitalWrite(ULTRA_TRIG_PIN, HIGH); delayMicroseconds(10);
  digitalWrite(ULTRA_TRIG_PIN, LOW);
  long duration = pulseIn(ULTRA_ECHO_PIN, HIGH, 50000); // 50ms timeout
  float distance = duration * 0.034 / 2.0;
  if (duration == 0 || distance <= 0) {
    return 999.0;
  } else {
    return distance;
  }
}

// Hàm quét siêu âm xung quanh và quyết định hướng rẽ
bool scanSurroundings() {
    float distLeft = 999.0;
    float distRight = 999.0;
    if (DEBUG_PRINT) Serial.println(F("   Scanning surroundings..."));
    myServo.write(SCAN_LEFT);
    delay(SCAN_DELAY); 
    distLeft = checkUltrasonicDistance();
    if (DEBUG_PRINT) { Serial.print(F("     Left distance: ")); Serial.println(distLeft); }
    myServo.write(SCAN_RIGHT);
    delay(SCAN_DELAY);
    distRight = checkUltrasonicDistance();
    if (DEBUG_PRINT) { Serial.print(F("     Right distance: ")); Serial.println(distRight); }
    myServo.write(SCAN_CENTER);
    delay(SCAN_DELAY / 2); 
    if (distRight > distLeft) {
        if (DEBUG_PRINT) Serial.println(F("     Decision: Turn RIGHT first."));
        return true; 
    } else {
        if (DEBUG_PRINT) Serial.println(F("     Decision: Turn LEFT first."));
        return false; 
    }
}

// Hàm thực hiện các bước tránh vật cản (Dựa vào avoidTurnRight)
void performAvoidance() {
    unsigned long currentTime = millis();
    switch (avoidState) {
        case 1: 
            if (avoidTurnRight) {
                 if (DEBUG_PRINT) Serial.println(F(" | AVOID STATE 1: Turning RIGHT (chosen)..."));
                 setLeftMotors(TURN_SPEED); setRightMotors(-TURN_SPEED);
            } else {
                 if (DEBUG_PRINT) Serial.println(F(" | AVOID STATE 1: Turning LEFT (chosen)..."));
                 setLeftMotors(-TURN_SPEED); setRightMotors(TURN_SPEED);
            }
            avoidStartTime = currentTime;
            avoidState = 11;
            break;
        case 11: 
            if (currentTime - avoidStartTime > TURN_DURATION) {
                 if (DEBUG_PRINT) Serial.println(F("   -> Initial Turn Complete."));
                 stopMotorsAndLed(); delay(100);
                 avoidState = 2; 
            }
            break;
        case 2: 
            if (DEBUG_PRINT) Serial.println(F(" | AVOID STATE 2: Going STRAIGHT..."));
            setLeftMotors(AVOID_SPEED); setRightMotors(AVOID_SPEED);
            avoidStartTime = currentTime;
            avoidState = 22;
            break;
        case 22: 
             if (currentTime - avoidStartTime > STRAIGHT_DURATION) {
                 if (DEBUG_PRINT) Serial.println(F("   -> Go STRAIGHT Complete."));
                 stopMotorsAndLed(); delay(100);
                 avoidState = 3; 
            }
            break;
        case 3: 
             if (avoidTurnRight) { 
                 if (DEBUG_PRINT) Serial.println(F(" | AVOID STATE 3: Turning LEFT (opposite)..."));
                 setLeftMotors(-TURN_SPEED); setRightMotors(TURN_SPEED);
            } else { 
                 if (DEBUG_PRINT) Serial.println(F(" | AVOID STATE 3: Turning RIGHT (opposite)..."));
                 setLeftMotors(TURN_SPEED); setRightMotors(-TURN_SPEED);
            }
            avoidStartTime = currentTime;
            avoidState = 33;
            break;
        case 33: 
            if (currentTime - avoidStartTime > TURN_DURATION) {
                 if (DEBUG_PRINT) Serial.println(F("   -> Second Turn Complete."));
                 stopMotorsAndLed(); delay(100);
                 avoidState = 4; 
            }
            break;
        case 4: 
             if (DEBUG_PRINT) Serial.println(F(" | AVOID STATE 4: Searching for LINE..."));
             setLeftMotors(SEARCH_SPEED); setRightMotors(SEARCH_SPEED);
             avoidStartTime = currentTime;
             avoidState = 44;
        case 44: 
            bool lineDetected = false;
            if (DEBUG_PRINT) Serial.print(F("   Searching... Sensors: "));
            for (int i = 0; i < 4; i++) { int val = analogRead(sens[i]); if (DEBUG_PRINT) { Serial.print(val); Serial.print(" "); }
                 if (val > threshold_for_turn) lineDetected = true; }
            if (DEBUG_PRINT) Serial.println();

            if (lineDetected) { 
                 if (DEBUG_PRINT) Serial.println(F("   -> LINE FOUND! Avoidance complete."));
                 stopMotorsAndLed(); delay(100);
                 isAvoidingObstacle = false; avoidState = 0;
                 previous_error = 0; previous_I = 0; pre_pos = 1500.0; stabilityCounter = 0;
            }
            else if (currentTime - avoidStartTime > SEARCH_TIMEOUT) { 
                 if (DEBUG_PRINT) Serial.println(F("   -> SEARCH TIMEOUT! Stopping."));
                 stopMotorsAndLed();
                 isAvoidingObstacle = false; avoidState = 0;
                 robotState = 0; 
            }
            break;
    }
}


/*
 * =================================================================================
 * /* --- TARGET: HÀM SETUP VÀ LOOP CHÍNH --- */
 * HÀM SETUP VÀ LOOP CHÍNH
 * =================================================================================
 */

void setup() {
  Serial.begin(9600);
  Serial.println(F("--- KHOI DONG XE DÒ LINE (V36 - Don Gian Comment) ---")); // Đổi tên V36

  pinMode(ULTRA_TRIG_PIN, OUTPUT);
  pinMode(ULTRA_ECHO_PIN, INPUT);
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, LOW);

  myServo.attach(SERVO_PIN);
  myServo.write(SCAN_CENTER); 

  manual_calibration(); 

  // Bắt đầu đếm 10 giây
  programStartTime = millis(); 
  
  robotState = 1; // Tự động BẬT
  Serial.println(F("Da hieu chinh xong. Tu dong BAT XE. (Grace Period 10s)"));

  stopMotorsAndLed(); // Tắt LED ban đầu
}

void loop() {
  // Ưu tiên tránh vật cản nếu đang trong quá trình
  if (isAvoidingObstacle) {
      digitalWrite(LED_BUILTIN, HIGH);
      performAvoidance();
      delay(10);
      return;
  }

  if (robotState == 0) { stopMotorsAndLed(); return; }

  digitalWrite(LED_BUILTIN, HIGH);

  // CASE 1: VAT CAN -> Quét và Bắt đầu tránh chữ U
  float currentDistance = checkUltrasonicDistance(); 
  if (currentDistance < OBSTACLE_DISTANCE) {
    
    // Chỉ bắt đầu tránh nếu chưa tránh và không đang xoay
    if (!isAvoidingObstacle && !isTurning) {
        if (DEBUG_PRINT) { Serial.print(F("CASE 1: VAT CAN o phia truoc (")); Serial.print(currentDistance); Serial.println(F("cm)! Bat dau quet...")); }
        stopMotorsAndLed(); 
        delay(200);
        avoidTurnRight = scanSurroundings(); 
        isAvoidingObstacle = true; 
        avoidState = 1;         
    } else if (DEBUG_PRINT && isTurning){ 
         Serial.println(F("CASE 1: VAT CAN! Ignored (turning)."));
         stopMotorsAndLed(); 
    }
  }
  // Nếu không có vật cản và không đang tránh, chạy logic dò line bình thường
  else {
    linetracingMode();
  }
  delay(10);
}
</code></pre>
            </div>
        </div>

    </main>
    
    <script>
        let originalCodeHTML = '';
        
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& nghĩa là toàn bộ chuỗi khớp
        }

        document.addEventListener('DOMContentLoaded', function() {
            originalCodeHTML = document.getElementById('code-content').innerHTML;
            renderLogicChart();
        });

        function scrollToCode(searchText) {
            const codeEl = document.getElementById('code-content');
            
            // Đặt lại HTML về gốc để xóa highlight cũ
            codeEl.innerHTML = originalCodeHTML;
            
            // Chuẩn bị searchText để dùng trong RegExp
            // Chúng ta cần tìm `searchText` nhưng nó ở trong comment `/* --- TARGET: ... --- */`
            const fullSearchText = `/* --- TARGET: ${searchText} --- */`;
            const safeSearchText = escapeRegExp(fullSearchText);
            const regex = new RegExp(safeSearchText, 'g');

            let targetFound = false;

            // Thay thế text tìm thấy bằng span highlight
            const newHTML = originalCodeHTML.replace(regex, (match) => {
                targetFound = true;
                return `<span id="scroll-target" class="highlight">${match}</span>`;
            });

            if (targetFound) {
                codeEl.innerHTML = newHTML;
                const target = document.getElementById('scroll-target');
                
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // Xóa highlight sau 3 giây
                    setTimeout(() => {
                        codeEl.innerHTML = originalCodeHTML;
                    }, 3000);
                }
            } else {
                // Nếu không tìm thấy, thử tìm hàm (fallback)
                scrollToCodeFallback(searchText);
            }
        }
        
        function scrollToCodeFallback(searchText) {
            const codeEl = document.getElementById('code-content');
            const safeSearchText = escapeRegExp(searchText);
            const regex = new RegExp(safeSearchText, 'g');
            let targetFound = false;
            
             const newHTML = originalCodeHTML.replace(regex, (match) => {
                targetFound = true;
                return `<span id="scroll-target" class="highlight">${match}</span>`;
            });
            
            if (targetFound) {
                codeEl.innerHTML = newHTML;
                const target = document.getElementById('scroll-target');
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    setTimeout(() => {
                        codeEl.innerHTML = originalCodeHTML;
                    }, 3000);
                }
            }
        }

        function copyCode() {
            const codeContent = document.getElementById('code-content').innerText;
            const copyBtn = document.getElementById('copy-btn');
            
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            
            try {
                document.execCommand('copy');
                copyBtn.innerText = 'Đã sao chép!';
                copyBtn.classList.add('bg-green-600');
                
                setTimeout(() => {
                    copyBtn.innerText = 'Sao chép Mã';
                    copyBtn.classList.remove('bg-green-600');
                }, 2000);
            } catch (err) {
                copyBtn.innerText = 'Lỗi!';
                copyBtn.classList.add('bg-red-600');
            }
            
            document.body.removeChild(tempTextArea);
        }

        function renderLogicChart() {
            const ctx = document.getElementById('logicCasesChart').getContext('2d');
            
            const wrapText = (ctx, text, maxWidth) => {
                if (text.length <= 16) return [text];
                const words = text.split(' ');
                let lines = [];
                let currentLine = '';
                for (let i = 0; i < words.length; i++) {
                    let testLine = currentLine + words[i] + ' ';
                    if (ctx.measureText(testLine).width > maxWidth && i > 0) {
                        lines.push(currentLine.trim());
                        currentLine = words[i] + ' ';
                    } else {
                        currentLine = testLine;
                    }
                }
                lines.push(currentLine.trim());
                return lines;
            };

            const chartData = {
                labels: [
                    'PID (CASE 6)',
                    'Cua Gắt / Ngã Rẽ (CASE 3A, 3B)',
                    'Phục Hồi Lệch Line (CASE 4A, 4B)',
                    'Phục Hồi Lệch Nhiều (CASE 4C, 4D)',
                    'Ngã Tư (CASE 2)',
                    'Trường hợp đặc biệt (CASE 1.5 - 1001)',
                    'Mất Line (CASE 5)'
                ],
                datasets: [{
                    label: 'Mức độ ưu tiên / Tần suất xử lý',
                    data: [1, 5, 4, 6, 7, 8, 3], 
                    backgroundColor: [
                        'rgba(54, 162, 235, 0.6)', // Blue
                        'rgba(255, 159, 64, 0.6)', // Orange
                        'rgba(75, 192, 192, 0.6)', // Teal
                        'rgba(255, 206, 86, 0.6)', // Yellow
                        'rgba(255, 99, 132, 0.6)',  // Red
                        'rgba(153, 102, 255, 0.6)',// Purple
                        'rgba(100, 100, 100, 0.6)' // Gray
                    ],
                    borderColor: [
                        'rgba(54, 162, 235, 1)',
                        'rgba(255, 159, 64, 1)',
                        'rgba(75, 192, 192, 1)',
                        'rgba(255, 206, 86, 1)',
                        'rgba(255, 99, 132, 1)',
                        'rgba(153, 102, 255, 1)',
                        'rgba(100, 100, 100, 1)'
                    ],
                    borderWidth: 1
                }]
            };

            new Chart(ctx, {
                type: 'bar',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Mức độ ưu tiên (Giá trị cao hơn = Ưu tiên cao hơn)'
                            },
                            beginAtZero: true
                        },
                        y: {
                            ticks: {
                                autoSkip: false,
                                callback: function(value, index, values) {
                                    const label = this.getLabelForValue(value);
                                    if (label.length > 25) {
                                        return label.substring(0, 25) + '...';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Phân loại các trường hợp logic dò line (CASEs)',
                            font: {
                                size: 18
                            }
                        },
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    label += `Ưu tiên ${context.raw}`;
                                    return label;
                                },
                                title: function(context) {
                                    return context[0].label;
                                }
                            }
                        }
                    }
                }
            });
        }
    </script>
</body>
</html>
