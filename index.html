<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trình mô phỏng Xe Dò Line (v8 - Đã sửa vật lý)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        /* ... (Toàn bộ CSS từ v7 được giữ nguyên) ... */
        canvas.draw-mode-freehand { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='black' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 20l-7.5-7.5 4.5-4.5L12 11l7.5 7.5L16 20z'/><path d='M12 11V4'/></svg>") 0 24, crosshair; }
        canvas.draw-mode-line { cursor: crosshair; }
        canvas.draw-mode-rect { cursor: crosshair; }
        canvas.draw-mode-eraser { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='black' stroke-width='2'><path d='M18.5 2.5a2.12 2.12 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z'/><path d='m15 5 3 3'/><path d='M6 16l-3 3.5a2.12 2.12 0 0 0 3 3L9.5 19'/></svg>") 0 24, crosshair; }
        canvas.simulate-mode { cursor: default; }
        canvas.place-car-mode { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'><path fill='black' d='M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z'/></svg>") 12 12, pointer; }
        
        #logPanel::-webkit-scrollbar, #codeEditor::-webkit-scrollbar { width: 6px; }
        #logPanel::-webkit-scrollbar-track, #codeEditor::-webkit-scrollbar-track { background: #4b5563; }
        #logPanel::-webkit-scrollbar-thumb, #codeEditor::-webkit-scrollbar-thumb { background: #9ca3af; border-radius: 3px; }

        .tool-button:disabled {
            background-color: #3b82f6;
            color: white;
            opacity: 1;
        }
        
        .grid-background {
            background-image:
                linear-gradient(to right, #e5e7eb 1px, transparent 1px),
                linear-gradient(to bottom, #e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #codeEditor {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            background-color: #1f2937;
            color: #d1d5db;
            border: 1px solid #4b5563;
            border-radius: 0.375rem;
        }
        
        #aiModal {
            transition: opacity 0.3s ease-in-out;
        }
        #aiModalContent {
            max-height: 80vh;
        }
        #aiModalContent article h1 { font-size: 1.5rem; font-weight: bold; margin-top: 1rem; }
        #aiModalContent article h2 { font-size: 1.25rem; font-weight: bold; margin-top: 0.75rem; }
        #aiModalContent article ul { list-style-type: disc; margin-left: 1.5rem; }
        #aiModalContent article code { background-color: #374151; color: #f9fafb; padding: 0.125rem 0.25rem; border-radius: 0.25rem; }
        #aiModalContent article pre { background-color: #1f2937; color: #d1d5db; padding: 0.5rem; border-radius: 0.375rem; overflow-x: auto; }

    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <h1 class="text-3xl font-bold text-gray-800 mb-4">Trình mô phỏng Xe Dò Line (v8 - Đã sửa vật lý)</h1>

    <!-- Bảng điều khiển chính -->
    <div class="flex flex-wrap justify-center gap-2 mb-2">
        <button id="drawButton" class="px-5 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 disabled:opacity-50" title="Chuyển sang chế độ vẽ">
            Vẽ
        </button>
        <button id="placeCarButton" class="px-5 py-2 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75 disabled:opacity-50" title="Click và Kéo để đặt vị trí và hướng xe">
            Đặt Xe
        </button>
        <button id="simulateButton" class="px-5 py-2 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75" title="Chạy mô phỏng">
            Chạy
        </button>
        <button id="stopButton" class="px-5 py-2 bg-red-600 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75" title="Dừng mô phỏng" disabled>
            Dừng
        </button>
        <button id="resetCarButton" class="px-5 py-2 bg-yellow-500 text-white font-semibold rounded-lg shadow-md hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-400 focus:ring-opacity-75" title="Đưa xe về vị trí xuất phát đã đặt">
            Reset Xe
        </button>
        <button id="clearMapButton" class="px-5 py-2 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-gray-600 focus:ring-opacity-75" title="Xóa toàn bộ bản đồ (để vẽ map mới)">
            Xóa Map
        </button>
        <button id="loadDefaultMapButton" class="px-4 py-2 bg-teal-600 text-white font-semibold rounded-lg shadow-md hover:bg-teal-700" title="Tải lại bản đồ thi đấu mặc định">
            Tải Map V29
        </button>
        <button id="saveMapButton" class="px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700" title="Sao chép dữ liệu map hiện tại vào clipboard">
            Lưu Map
        </button>
        <button id="loadMapButton" class="px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700" title="Tải map tùy chỉnh từ chuỗi text">
            Tải Map
        </button>
    </div>

    <!-- Thanh công cụ vẽ -->
    <div id="drawingTools" class="flex flex-wrap justify-center items-center gap-2 mb-4 p-2 bg-gray-100 rounded-lg shadow">
        <button id="toolFreehand" class="tool-button px-3 py-2 bg-white text-gray-800 rounded shadow hover:bg-blue-100 disabled:hover:bg-blue-600">Vẽ Tự Do</button>
        <button id="toolLine" class="tool-button px-3 py-2 bg-white text-gray-800 rounded shadow hover:bg-blue-100 disabled:hover:bg-blue-600">Đường Thẳng</button>
        <button id="toolArc" class="tool-button px-3 py-2 bg-white text-gray-800 rounded shadow hover:bg-blue-100 disabled:hover:bg-blue-600">Cung (3-click)</button>
        <button id="toolTriangle" class="tool-button px-3 py-2 bg-white text-gray-800 rounded shadow hover:bg-blue-100 disabled:hover:bg-blue-600">Tam Giác (3-click)</button>
        <button id="toolRect" class="tool-button px-3 py-2 bg-white text-gray-800 rounded shadow hover:bg-blue-100 disabled:hover:bg-blue-600">Chữ Nhật</button>
        <button id="toolEraser" class="tool-button px-3 py-2 bg-white text-gray-800 rounded shadow hover:bg-blue-100 disabled:hover:bg-blue-600">Tẩy</button>
        <button id="undoButton" class="tool-button px-3 py-2 bg-white text-gray-800 rounded shadow hover:bg-blue-100 disabled:opacity-50" disabled>Undo</button>
        <button id="redoButton" class="tool-button px-3 py-2 bg-white text-gray-800 rounded shadow hover:bg-blue-100 disabled:opacity-50" disabled>Redo</button>
        <button id="toggleGridButton" class="tool-button px-3 py-2 bg-white text-gray-800 rounded shadow hover:bg-blue-100">Hiện Lưới</button>
        <div class="flex items-center space-x-2 bg-white p-2 rounded shadow">
            <label for="lineWidthSlider" class="text-sm">Nét vẽ:</label>
            <input id="lineWidthSlider" type="range" min="2" max="50" value="18" class="w-24">
        </div>
    </div>

    <!-- Tùy chọn mô phỏng -->
    <div id="simulationOptions" class="flex flex-wrap justify-center items-center gap-2 mb-4 p-2 bg-gray-100 rounded-lg shadow">
        <div class="flex items-center space-x-2 bg-white p-2 rounded shadow">
            <label for="carSpeedSlider" class="text-sm">Tốc độ xe:</label>
            <input id="carSpeedSlider" type="range" min="0.5" max="5" step="0.1" value="1.5" class="w-32">
            <span id="carSpeedValue" class="text-sm w-8 text-right">1.5</span>
        </div>
        <!-- (CẬP NHẬT V8) Tùy chỉnh hằng số PID (Giá trị mặc định đã giảm 100 lần) -->
        <div class="flex items-center space-x-2 bg-white p-2 rounded shadow">
            <label for="pid_KP" class="text-sm">KP:</label>
            <input id="pid_KP" type="number" value="0.5" step="0.1" class="w-16 p-1 border rounded">
            <label for="pid_KI" class="text-sm">KI:</label>
            <input id="pid_KI" type="number" value="0.001" step="0.001" class="w-16 p-1 border rounded">
            <label for="pid_KD" class="text-sm">KD:</label>
            <input id="pid_KD" type="number" value="0.1" step="0.1" class="w-16 p-1 border rounded">
        </div>
    </div>

    <!-- Khu vực chính: Canvas và Cột bên phải -->
    <div class="flex flex-col md:flex-row w-full max-w-screen-2xl">
        <!-- Canvas -->
        <div class="flex-grow">
            <canvas id="simulationCanvas" width="1200" height="800" class="rounded-lg shadow-lg border-2 border-gray-400"></canvas>
        </div>

        <!-- Cột bên phải (Log, Code Editor, AI Tools) -->
        <div id="rightColumn" class="md:ml-4 mt-4 md:mt-0 w-full md:w-96 flex-shrink-0 flex flex-col gap-4">
            <!-- Bảng Log -->
            <div id="logPanelContainer" class="flex-shrink-0">
                <div id="logPanel" class="bg-gray-800 text-white p-4 rounded-lg shadow-lg h-72 md:h-80 overflow-y-auto">
                    <h3 class="text-lg font-bold mb-2 text-white border-b border-gray-600 pb-2">Bảng Ghi Log</h3>
                    <pre id="logContent" class="text-sm text-gray-200">
--- TRẠNG THÁI XE ---
Chờ mô phỏng...
                    </pre>
                </div>
            </div>
            
            <!-- Trình soạn thảo code -->
            <div id="codeEditorContainer" class="flex-grow flex flex-col">
                <h3 class="text-lg font-bold mb-2 text-gray-800">Trình soạn thảo Code (Bộ Não Xe)</h3>
                <textarea id="codeEditor" class="w-full flex-grow h-64 md:h-auto" style="min-height: 250px;"></textarea>
                <button id="loadCodeButton" class="mt-2 w-full px-5 py-2 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500">
                    Nạp Code (Cập nhật Bộ Não)
                </button>
            </div>
            
            <!-- Bảng điều khiển AI -->
            <div id="aiControls" class="flex flex-col gap-2 p-4 bg-gray-100 rounded-lg shadow">
                 <h3 class="text-lg font-bold text-gray-800">Công cụ Gemini AI ✨</h3>
                 <textarea id="aiPromptInput" class="w-full h-24 p-2 border border-gray-300 rounded-md" placeholder="Mô tả logic bạn muốn (ví dụ: 'rẽ trái khi 2 cảm biến trái chạm vạch') hoặc đặt câu hỏi về code..."></textarea>
                 <div class="flex gap-2">
                    <button id="generateCodeButton" class="flex-1 px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-wait">
                         ✨ Tạo Code
                    </button>
                    <button id="debugCodeButton" class="flex-1 px-4 py-2 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 disabled:opacity-50 disabled:cursor-wait">
                         ✨ Phân tích Code
                    </button>
                 </div>
                 <p id="aiStatus" class="text-sm text-gray-600 text-center h-4"></p>
            </div>

        </div>
    </div>
    
    <!-- AI Modal -->
    <div id="aiModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 opacity-0 pointer-events-none">
        <div class="bg-white rounded-lg shadow-2xl w-full max-w-2xl">
            <div class="flex justify-between items-center p-4 border-b">
                <h2 class="text-xl font-bold text-gray-800">✨ Phân tích từ Gemini AI</h2>
                <button id="closeAiModalButton" class="text-gray-500 hover:text-gray-800 text-3xl">&times;</button>
            </div>
            <div id="aiModalContent" class="p-6 overflow-y-auto">
                <article class="prose prose-sm max-w-none"></article>
            </div>
        </div>
    </div>


    <script>
        // --- Lấy các phần tử DOM ---
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const logContent = document.getElementById('logContent');
        
        const drawButton = document.getElementById('drawButton');
        const placeCarButton = document.getElementById('placeCarButton');
        const simulateButton = document.getElementById('simulateButton');
        const stopButton = document.getElementById('stopButton');
        const resetCarButton = document.getElementById('resetCarButton');
        const clearMapButton = document.getElementById('clearMapButton');
        const loadDefaultMapButton = document.getElementById('loadDefaultMapButton');
        const saveMapButton = document.getElementById('saveMapButton');
        const loadMapButton = document.getElementById('loadMapButton');
        
        const drawingTools = document.getElementById('drawingTools');
        const toolFreehand = document.getElementById('toolFreehand');
        const toolLine = document.getElementById('toolLine');
        const toolArc = document.getElementById('toolArc');
        const toolTriangle = document.getElementById('toolTriangle');
        const toolRect = document.getElementById('toolRect');
        const toolEraser = document.getElementById('toolEraser');
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton');
        const toggleGridButton = document.getElementById('toggleGridButton');
        const lineWidthSlider = document.getElementById('lineWidthSlider');
        
        const simulationOptions = document.getElementById('simulationOptions');
        const carSpeedSlider = document.getElementById('carSpeedSlider');
        const carSpeedValue = document.getElementById('carSpeedValue');
        const pidKPInput = document.getElementById('pid_KP');
        const pidKIInput = document.getElementById('pid_KI');
        const pidKDInput = document.getElementById('pid_KD');
        
        const codeEditor = document.getElementById('codeEditor');
        const loadCodeButton = document.getElementById('loadCodeButton');

        const aiPromptInput = document.getElementById('aiPromptInput');
        const generateCodeButton = document.getElementById('generateCodeButton');
        const debugCodeButton = document.getElementById('debugCodeButton');
        const aiStatus = document.getElementById('aiStatus');
        const aiModal = document.getElementById('aiModal');
        const aiModalContent = document.getElementById('aiModalContent').querySelector('article');
        const closeAiModalButton = document.getElementById('closeAiModalButton');


        // --- CẤU HÌNH ---
        let LINE_COLOR = '#000000';
        const BACKGROUND_COLOR = '#FFFFFF';
        let LINE_WIDTH = 18;
        let ERASER_WIDTH = 20;
        const SENSOR_COLOR_ON = 'red';
        const SENSOR_COLOR_OFF = 'green';
        const GRID_SIZE = 20;
        
        // --- BIẾN TRẠNG THÁI ---
        let currentMode = 'draw';
        let currentDrawTool = 'freehand';
        let isRunning = false;
        let isDrawing = false; 
        let isGridVisible = false;
        
        let animationFrameId = null;
        let mapImageData = null; 
        
        let lineStartPoint = null;
        let previewMapData = null; 
        
        let drawState = { clickCount: 0, p1: null, p2: null };
        
        let history = [];
        let historyIndex = -1;
        
        let initialCarX = 100;
        let initialCarY = 750; 
        let initialCarAngle = -Math.PI / 2; 

        // --- Đối tượng Xe (Cập nhật V7) ---
        const car = {
            x: initialCarX,
            y: initialCarY,
            width: 20,
            height: 30,
            angle: initialCarAngle,
            speed: 1.5,
            turnSpeed: 0.05,
            sensors: [
                { id: 'S1', x: -15, y: -18, value: 0 }, // Trái
                { id: 'S2', x: -5, y: -18, value: 0 },  // Gần trái
                { id: 'S3', x: 5, y: -18, value: 0 },   // Gần phải
                { id: 'S4', x: 15, y: -18, value: 0 }    // Phải
            ],
            wheels: [
                { x: -15, y: -10, width: 6, height: 12 },
                { x: 15, y: -10, width: 6, height: 12 },
                { x: -15, y: 10, width: 6, height: 12 },
                { x: 15, y: 10, width: 6, height: 12 }
            ],
            draw: function() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = 'blue';
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.fillStyle = 'cyan';
                ctx.beginPath();
                ctx.moveTo(0, -this.height / 2 - 5);
                ctx.lineTo(-5, -this.height / 2);
                ctx.lineTo(5, -this.height / 2);
                ctx.closePath();
                ctx.fill();
                this.wheels.forEach(wheel => {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(wheel.x - wheel.width / 2, wheel.y - wheel.height / 2, wheel.width, wheel.height);
                });
                this.sensors.forEach(sensor => {
                    ctx.fillStyle = sensor.value ? SENSOR_COLOR_ON : SENSOR_COLOR_OFF;
                    ctx.beginPath();
                    ctx.arc(sensor.x, sensor.y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
                ctx.restore();
            },
            update: function(leftSpeed, rightSpeed) {
                const linearSpeed = (leftSpeed + rightSpeed) / 2 * this.speed; 
                const angularSpeed = (rightSpeed - leftSpeed) / this.width; 
                
                this.angle += angularSpeed * this.turnSpeed;
                this.x += Math.cos(this.angle) * linearSpeed;
                this.y += Math.sin(this.angle) * linearSpeed;
            },
            readSensors: function() {
                const see_line_threshold = 0.7;
                
                this.sensors.forEach(sensor => {
                    const cosA = Math.cos(this.angle);
                    const sinA = Math.sin(this.angle);
                    const sensorX = this.x + sensor.x * cosA - sensor.y * sinA;
                    const sensorY = this.y + sensor.x * sinA + sensor.y * cosA;
                    
                    try {
                        const pixelData = ctx.getImageData(Math.round(sensorX), Math.round(sensorY), 1, 1).data;
                        const brightness = (pixelData[0] + pixelData[1] + pixelData[2]) / 3;
                        const analogValue = 1.0 - (brightness / 255.0); 
                        
                        sensor.value = (analogValue > see_line_threshold) ? 1 : 0;
                        sensor.analog = analogValue; 
                        
                    } catch (e) {
                        sensor.value = 0;
                        sensor.analog = 0.0;
                    }
                });
            },
            reset: function() {
                this.x = initialCarX;
                this.y = initialCarY;
                this.angle = initialCarAngle;
            }
        };

        // --- BỘ NÃO XE (LOGIC V29 - ĐÃ DỊCH SANG JS) ---
        const CarBrain = {
            // (CẬP NHẬT V8) Hằng số PID mặc định đã giảm 100 lần
            KP: 0.5,
            KI: 0.001,
            KD: 0.1,
            
            // Hằng số tốc độ (chuẩn hóa 0.0-2.0)
            PID_SPEED_STABLE: 1.0,   
            PID_SPEED_UNSTABLE: 0.8, 
            PID_KP_STABLE: 0.2, // (KP 20.0 -> 0.2)
            PID_KP_UNSTABLE: 0.5, // (KP 50.0 -> 0.5)
            TURN_SPEED_LINE: 1.5,    
            
            LOST_LINE_TIMEOUT: 500,

            lastError: 0,
            integral: 0,
            pre_pos: 1500.0, 
            stabilityCounter: 0,

            mapState: 0,
            choSuKienMoi: true,
            
            isTurning: false,
            turnStartTime: 0,
            turningRight: false,
            currentTurnSpeed: 0,
            currentMaxTurnTime: 0,
            
            lostLineStartTime: 0,

            reset: function() {
                this.lastError = 0;
                this.integral = 0;
                this.pre_pos = 1500.0;
                this.stabilityCounter = 0;
                this.mapState = 0;
                this.choSuKienMoi = true;
                this.isTurning = false;
                this.turnStartTime = 0;
                this.lostLineStartTime = 0;
                
                // (CẬP NHẬT V8) Đọc giá trị PID đã điều chỉnh từ UI
                this.KP = parseFloat(pidKPInput.value) || 0.5;
                this.KI = parseFloat(pidKIInput.value) || 0.001;
                this.KD = parseFloat(pidKDInput.value) || 0.1;
                // Tự động tính Kp stable
                this.PID_KP_STABLE = this.KP * 0.4; // 40% của Kp unstable
                this.PID_KP_UNSTABLE = this.KP;
            },
            
            update: function(sensors) {
                try {
                    return this.customUpdate(sensors, this);
                } catch (e) {
                    console.error("Lỗi trong code 'Bộ Não Xe' của bạn:", e);
                    stopSimulationWithError(`Lỗi code: ${e.message}`);
                    return {
                        motorSpeeds: { left: 0, right: 0 },
                        logData: { status: "LỖI CODE! Đã dừng." }
                    };
                }
            },
            
            // Hàm 'customUpdate' (LOGIC V29 - Đã "biến tấu" vật lý)
            customUpdate: function(sensors, brain) {
                
                const currentTime = Date.now();
                let logData = { status: "..." };

                // 1. ƯU TIÊN KIỂM TRA XOAY (performTurn)
                if (brain.isTurning) {
                    logData.status = brain.turningRight ? "Đang Rẽ Phải..." : "Đang Rẽ Trái...";
                    
                    const s2 = sensors.find(s => s.id === 'S2').value;
                    const s3 = sensors.find(s => s.id === 'S3').value;
                    let lineFound = (s2 === 1 || s3 === 1);
                    
                    if (currentTime - brain.turnStartTime > brain.currentMaxTurnTime) {
                        lineFound = true;
                        logData.status = "Rẽ Bị Timeout!";
                    }

                    if (lineFound) {
                        brain.isTurning = false;
                        brain.lastError = 0; brain.integral = 0; brain.pre_pos = 1500.0;
                        return { motorSpeeds: { left: 0, right: 0 }, logData: { status: "Hoàn thành rẽ!", mapState: brain.mapState } };
                    }
                    
                    const turnSpeed = brain.currentTurnSpeed;
                    if (brain.turningRight) {
                        return { motorSpeeds: { left: turnSpeed, right: -turnSpeed }, logData: { status: "Đang Rẽ Phải...", mapState: brain.mapState } };
                    } else {
                        return { motorSpeeds: { left: -turnSpeed, right: turnSpeed }, logData: { status: "Đang Rẽ Trái...", mapState: brain.mapState } };
                    }
                }
                
                // 2. ĐỌC CẢM BIẾN
                const s1 = sensors.find(s => s.id === 'S1').value;
                const s2 = sensors.find(s => s.id === 'S2').value;
                const s3 = sensors.find(s => s.id === 'S3').value;
                const s4 = sensors.find(s => s.id === 'S4').value;

                // 3. PHÂN LOẠI SỰ KIỆN
                const laNgaTu = (s1 && s2 && s3 && s4);
                const laNgaBaTrai = (s1 && s2 && s3 && !s4);    // 1110
                const laNgaBaPhai = (!s1 && s2 && s3 && s4);    // 0111
                const laTamGiac = (s1 && !s2 && !s3 && s4);     // 1001
                const laCuoiDuong = (!s1 && !s2 && !s3 && !s4);  // 0000
                const laPhucHoiTrai = (!s1 && s2 && !s3 && !s4); // 0100
                const laPhucHoiPhai = (!s1 && !s2 && s3 && !s4); // 0010
                
                const laSuKienNgaRe = laNgaTu || laNgaBaTrai || laNgaBaPhai || laTamGiac;

                if (!laSuKienNgaRe && !(laCuoiDuong && brain.mapState != 6)) {
                    brain.choSuKienMoi = true;
                }
                
                logData.mapState = brain.mapState;

                // 4. MÁY TRẠNG THÁI
                if (!brain.choSuKienMoi) {
                    logData.status = "Đang chờ qua vạch...";
                    return { motorSpeeds: { left: brain.PID_SPEED_STABLE, right: brain.PID_SPEED_STABLE }, logData };
                }
                
                switch (brain.mapState) {
                    case 0: // Tìm 0111 (lần 1)
                        if (laNgaBaPhai) {
                            logData.status = "MAP 0 -> 1: Thấy 0111 (Lần 1). Bỏ qua.";
                            brain.choSuKienMoi = false;
                            brain.mapState = 1;
                            brain.stabilityCounter = 0; brain.pre_pos = 1500.0; brain.lastError = 0.0; brain.integral = 0.0;
                            return { motorSpeeds: { left: brain.PID_SPEED_STABLE, right: brain.PID_SPEED_STABLE }, logData };
                        }
                        break;

                    case 1: // Tìm 0111 (lần 2)
                        if (laNgaBaPhai) {
                            logData.status = "MAP 1 -> 2: Thấy 0111 (Lần 2). Bỏ qua.";
                            brain.choSuKienMoi = false;
                            brain.mapState = 2;
                            brain.stabilityCounter = 0; brain.pre_pos = 1500.0; brain.lastError = 0.0; brain.integral = 0.0;
                            return { motorSpeeds: { left: brain.PID_SPEED_STABLE, right: brain.PID_SPEED_STABLE }, logData };
                        }
                        break;

                    case 2: // Tìm 0111 (lần 3) -> RẼ PHẢI
                        if (laNgaBaPhai) {
                            logData.status = "MAP 2 -> 3: Thấy 0111 (Lần 3). Rẽ Phải!";
                            brain.choSuKienMoi = false;
                            brain.mapState = 3;
                            brain.stabilityCounter = 0;
                            brain.isTurning = true; brain.turnStartTime = currentTime; brain.turningRight = true; 
                            brain.currentTurnSpeed = brain.TURN_SPEED_LINE; brain.currentMaxTurnTime = 1200; // Tăng thời gian
                            return { motorSpeeds: { left: brain.currentTurnSpeed, right: -brain.currentTurnSpeed }, logData };
                        }
                        break;

                    case 3: // Tìm Ngã tư (1110 / 1111) -> RẼ TRÁI
                        if (laNgaBaTrai || laNgaTu) {
                            logData.status = "MAP 3 -> 4: Thấy Ngã Tư. Rẽ Trái!";
                            brain.choSuKienMoi = false;
                            brain.mapState = 4;
                            brain.stabilityCounter = 0;
                            brain.isTurning = true; brain.turnStartTime = currentTime; brain.turningRight = false; 
                            brain.currentTurnSpeed = brain.TURN_SPEED_LINE; brain.currentMaxTurnTime = 1000;
                            return { motorSpeeds: { left: -brain.currentTurnSpeed, right: brain.currentTurnSpeed }, logData };
                        }
                        break;
                        
                    case 4: // Tìm 0111 (sau ngã tư) -> RẼ PHẢI
                        if (laNgaBaPhai) {
                            logData.status = "MAP 4 -> 5: Thấy 0111. Rẽ Phải.";
                            brain.choSuKienMoi = false;
                            brain.mapState = 5;
                            brain.stabilityCounter = 0;
                            brain.isTurning = true; brain.turnStartTime = currentTime; brain.turningRight = true; 
                            brain.currentTurnSpeed = brain.TURN_SPEED_LINE; brain.currentMaxTurnTime = 1000;
                            return { motorSpeeds: { left: brain.currentTurnSpeed, right: -brain.currentTurnSpeed }, logData };
                        }
                        break;

                    case 5: // Tìm "Tam Giác" (1001) -> RẼ TRÁI
                        if (laTamGiac) {
                            logData.status = "MAP 5 -> 6: Thấy Tam Giác (1001). Rẽ Trái.";
                            brain.choSuKienMoi = false;
                            brain.mapState = 6;
                            brain.stabilityCounter = 0;
                            brain.isTurning = true; brain.turnStartTime = currentTime; brain.turningRight = false; 
                            brain.currentTurnSpeed = brain.TURN_SPEED_LINE; brain.currentMaxTurnTime = 1000;
                            return { motorSpeeds: { left: -brain.currentTurnSpeed, right: brain.currentTurnSpeed }, logData };
                        }
                        break;

                    case 6: // Tìm "Cuối Đường" (0000)
                        if (laCuoiDuong) {
                            if (brain.lostLineStartTime === 0) {
                                brain.lostLineStartTime = currentTime; 
                                logData.status = "MAP 6 -> 7: Thấy 0000. Kiểm tra...";
                            }
                            if (currentTime - brain.lostLineStartTime > brain.LOST_LINE_TIMEOUT) {
                                logData.status = "HOÀN THÀNH! Dừng vĩnh viễn.";
                                brain.mapState = 7; 
                                stopSimulationWithError("Đã chạy xong lộ trình V29.");
                                return { motorSpeeds: { left: 0, right: 0 }, logData };
                            }
                            return { motorSpeeds: { left: 0, right: 0 }, logData };
                        } else {
                            brain.lostLineStartTime = 0;
                        }
                        break;

                    case 7: // Đã dừng
                        logData.status = "Đã dừng.";
                        stopSimulationWithError("Đã chạy xong lộ trình V29.");
                        return { motorSpeeds: { left: 0, right: 0 }, logData };
                }
                
                // 5. NẾU KHÔNG CÓ SỰ KIỆN (Logic PID và Phục hồi)
                if (laPhucHoiTrai) { // 0100
                    brain.lostLineStartTime = 0; logData.status = "Phục hồi trái (0100)"; brain.stabilityCounter = 0;
                    brain.lastError = -0.8;
                    return { motorSpeeds: { left: -0.8, right: 1.2 }, logData };
                }
                else if (laPhucHoiPhai) { // 0010
                    brain.lostLineStartTime = 0; logData.status = "Phục hồi phải (0010)"; brain.stabilityCounter = 0;
                    brain.lastError = 0.8;
                    return { motorSpeeds: { left: 1.2, right: -0.8 }, logData };
                }
                else if (laCuoiDuong) { // 0000 (nhưng state != 6)
                    brain.stabilityCounter = 0;
                    if (brain.lostLineStartTime === 0) {
                        brain.lostLineStartTime = currentTime; 
                        logData.status = "Mất line tạm thời (0000)...";
                    }
                    if (currentTime - brain.lostLineStartTime > brain.LOST_LINE_TIMEOUT) {
                        logData.status = "Mất line TIMEOUT! Dừng.";
                        stopSimulationWithError("Mất line (0000) quá lâu.");
                        return { motorSpeeds: { left: 0, right: 0 }, logData };
                    } else {
                        logData.status = "Đang tìm line...";
                        const recoverySpeed = 1.0;
                        if (brain.lastError < -0.5) return { motorSpeeds: { left: recoverySpeed, right: -recoverySpeed / 2 }, logData };
                        else if (brain.lastError > 0.5) return { motorSpeeds: { left: -recoverySpeed / 2, right: recoverySpeed }, logData };
                        else return { motorSpeeds: { left: recoverySpeed, right: recoverySpeed }, logData };
                    }
                }
                else { // LOGIC PID BÌNH THƯỜNG
                    brain.lostLineStartTime = 0;
                    
                    const s1_a = sensors.find(s => s.id === 'S1').analog;
                    const s2_a = sensors.find(s => s.id === 'S2').analog;
                    const s3_a = sensors.find(s => s.id === 'S3').analog;
                    const s4_a = sensors.find(s => s.id === 'S4').analog;
                    const sumError_all = s1_a + s2_a + s3_a + s4_a;
                    
                    let pos_pid = 0.0;
                    if (sumError_all < 0.01) {
                        pos_pid = brain.pre_pos; 
                    } else {
                        pos_pid = (s1_a * 0) + (s2_a * 1000) + (s3_a * 2000) + (s4_a * 3000);
                        pos_pid /= sumError_all;
                        brain.pre_pos = pos_pid;
                    }
                    
                    if (pos_pid > 1100 && pos_pid < 1900) brain.stabilityCounter++; 
                    else brain.stabilityCounter = 0;

                    let current_initSpeed, current_Kp;
                    if (brain.stabilityCounter > 20) {
                        logData.status = "PID (Ổn định)";
                        current_initSpeed = brain.PID_SPEED_STABLE;
                        current_Kp = brain.PID_KP_STABLE;
                    } else {
                        logData.status = "PID (Tìm kiếm)";
                        current_initSpeed = brain.PID_SPEED_UNSTABLE;
                        current_Kp = brain.PID_KP_UNSTABLE;
                    }
                    
                    const error = (pos_pid - 1500.0) / 500.0; // Error từ -3.0 đến 3.0
                    const P = error;
                    brain.integral = brain.integral + P; 
                    brain.integral = Math.max(-100.0, Math.min(100.0, brain.integral)); // Giới hạn I
                    const D = error - brain.lastError;
                    
                    // (CẬP NHẬT V8) Hằng số Kp, Ki, Kd đã được scale
                    const PID_value = (current_Kp * P) + (brain.KI * brain.integral) + (brain.KD * D);
                    brain.lastError = error;
                    
                    let leftSpeed = current_initSpeed + PID_value;
                    let rightSpeed = current_initSpeed - PID_value;
                    
                    // Giới hạn tốc độ mô phỏng
                    leftSpeed = Math.max(-1.5, Math.min(1.5, leftSpeed));
                    rightSpeed = Math.max(-1.5, Math.min(1.5, rightSpeed));
                    
                    logData.error = error.toFixed(2);
                    logData.PID = PID_value.toFixed(2);
                    logData.leftSpeed = leftSpeed.toFixed(2);
                    logData.rightSpeed = rightSpeed.toFixed(2);

                    return { motorSpeeds: { left: leftSpeed, right: rightSpeed }, logData };
                }
            }
        };

        // --- LOGIC GEMINI API (V7) ---
        const apiKey = "";
        const genAIApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        async function callGeminiAPI(systemPrompt, userPrompt) {
            setAiLoading(true);
            aiStatus.textContent = "Đang kết nối với Gemini AI...";
            
            const payload = {
                contents: [{ parts: [{ text: userPrompt }] }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };

            try {
                const response = await fetch(genAIApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.json();
                    throw new Error(`API Error: ${response.status} - ${errorBody.error?.message || response.statusText}`);
                }

                const result = await response.json();
                const candidate = result.candidates?.[0];
                
                if (candidate && candidate.content?.parts?.[0]?.text) {
                    aiStatus.textContent = "AI đã phản hồi!";
                    setAiLoading(false);
                    return candidate.content.parts[0].text;
                } else {
                    throw new Error("Không nhận được nội dung hợp lệ từ AI.");
                }
            } catch (e) {
                console.error("Lỗi gọi Gemini API:", e);
                aiStatus.textContent = `Lỗi: ${e.message}`;
                setAiLoading(false);
                return null;
            }
        }
        
        function setAiLoading(isLoading) {
            generateCodeButton.disabled = isLoading;
            debugCodeButton.disabled = isLoading;
            if (isLoading) {
                aiStatus.textContent = "AI đang xử lý...";
            } else {
                 setTimeout(() => { aiStatus.textContent = ""; }, 3000);
            }
        }

        generateCodeButton.addEventListener('click', async () => {
            const userPrompt = aiPromptInput.value;
            if (!userPrompt) {
                alert("Vui lòng nhập mô tả logic của bạn vào ô bên trên.");
                return;
            }
            
            const systemPrompt = `
You are an expert JavaScript programmer specializing in line follower robot logic.
Your task is to generate ONLY the JavaScript code for the body of a function: \`customUpdate(sensors, brain)\`.
Do NOT include the function definition \`function customUpdate(sensors, brain) { ... }\` or any surrounding text, comments, or markdown ticks (\`\`\`).
You must generate only the raw JavaScript code for the function's body.

The 'sensors' array has this structure (4 sensors in a line):
[
  { id: 'S1', value: 0, analog: 0.0 }, // Far Left
  { id: 'S2', value: 0, analog: 0.0 }, // Mid Left
  { id: 'S3', value: 0, analog: 0.0 }, // Mid Right
  { id: 'S4', value: 0, analog: 0.0 }  // Far Right
]
'value' is 1 (black line) or 0 (white background).
'analog' is 0.0 (white) to 1.0 (black), use this for PID position calculation.

The 'brain' object contains:
- brain.lastError (number)
- brain.integral (number)
- brain.pre_pos (number)
- brain.mapState (number)
- brain.choSuKienMoi (boolean)
- brain.isTurning (boolean)
- brain.KP, brain.KI, brain.KD (PID constants - THESE ARE SMALL, e.g., 0.5)
You MUST use these properties.

Your code MUST return an object with this exact structure:
{
  motorSpeeds: { left: number, right: number },
  logData: { status: string, ...any_other_logs }
}
Respond in Vietnamese for comments if any.
`;
            
            let generatedCode = await callGeminiAPI(systemPrompt, userPrompt);
            
            if (generatedCode) {
                generatedCode = generatedCode.replace(/^```javascript\n?|```$/g, "").trim();
                codeEditor.value = generatedCode;
                aiStatus.textContent = "Đã tạo code! Đang nạp code...";
                loadCodeButton.click();
            }
        });

        debugCodeButton.addEventListener('click', async () => {
            const userCode = codeEditor.value;
            if (!userCode) {
                alert("Không có code nào trong trình soạn thảo để phân tích.");
                return;
            }
            
            const systemPrompt = `
Bạn là một chuyên gia đánh giá code (code reviewer) chuyên về logic robot dò line (PID, v.v.).
Nhiệm vụ của bạn là phân tích code JavaScript của người dùng.
Code này dùng 4 cảm biến thẳng hàng: S1 (ngoài trái), S2 (trong trái), S3 (trong phải), S4 (ngoài phải).
Code cũng sử dụng một máy trạng thái (brain.mapState) để xử lý lộ trình.
Hãy phản hồi bằng Tiếng Việt.
1. Giải thích logic của code, đặc biệt là máy trạng thái (mapState).
2. Xác định các lỗi tiềm ẩn hoặc các trường hợp biên.
3. Gợi ý các cải tiến.
Hãy định dạng câu trả lời của bạn rõ ràng bằng Markdown (dùng #, *, \`code\`).
`;
            const userPrompt = `
Hãy phân tích code xe dò line sau đây, giải thích logic, tìm lỗi và gợi ý cải tiến:

\`\`\`javascript
${userCode}
\`\`\`
`;
            
            const analysis = await callGeminiAPI(systemPrompt, userPrompt);
            
            if (analysis) {
                let htmlAnalysis = analysis
                    .replace(/```javascript\n/g, '<pre><code>')
                    .replace(/```\n/g, '</code></pre>')
                    .replace(/```/g, '</code></pre>')
                    .replace(/`([^`]+)`/g, '<code>$1</code>')
                    .replace(/^# (.*$)/gmi, '<h1>$1</h1>')
                    .replace(/^## (.*$)/gmi, '<h2>$1</h2>')
                    .replace(/\n\*(.*)/g, '<ul>\n  <li>$1</li>\n</ul>')
                    .replace(/<\/ul>\n<ul>/g, '')
                    .replace(/\n\n/g, '<br><br>');
                
                aiModalContent.innerHTML = htmlAnalysis;
                showAiModal();
            }
        });
        
        function showAiModal() {
            aiModal.classList.remove('opacity-0', 'pointer-events-none');
        }
        function hideAiModal() {
            aiModal.classList.add('opacity-0', 'pointer-events-none');
        }
        closeAiModalButton.addEventListener('click', hideAiModal);
        aiModal.addEventListener('click', (e) => {
            if (e.target === aiModal) {
                hideAiModal();
            }
        });


        // --- CODE EDITOR LOGIC (CẬP NHẬT V8) ---
        codeEditor.value = CarBrain.customUpdate.toString()
            .replace(/^function\s*customUpdate\s*\([^)]*\)\s*\{/, '')
            .replace(/\}$/, '')
            .trim();
        
        loadCodeButton.addEventListener('click', () => {
            const userCode = codeEditor.value;
            try {
                const newUpdateFunction = new Function('sensors', 'brain', userCode);
                CarBrain.customUpdate = newUpdateFunction;
                CarBrain.reset(); 
                
                loadCodeButton.textContent = "Đã nạp code thành công!";
                loadCodeButton.classList.remove('bg-green-600', 'hover:bg-green-700');
                loadCodeButton.classList.add('bg-blue-500');
                setTimeout(() => {
                    loadCodeButton.textContent = "Nạp Code (Cập nhật Bộ Não)";
                    loadCodeButton.classList.remove('bg-blue-500');
                    loadCodeButton.classList.add('bg-green-600', 'hover:bg-green-700');
                }, 2000);
                
            } catch (e) {
                console.error("Lỗi cú pháp trong code của bạn:", e);
                alert(`Lỗi cú pháp trong code của bạn:\n\n${e.message}\n\nHãy kiểm tra lại và nhấn 'Nạp Code'.`);
            }
        });

        
        // --- CÁC HÀM CẬP NHẬT GIAO DIỆN (CẬP NHẬT V8) ---
        function updateLogPanel(carState, sensors, carBrainLog) {
            logContent.innerHTML = `
--- TRẠNG THÁI XE ---
X: ${carState.x.toFixed(2)}
Y: ${carState.y.toFixed(2)}
Góc: ${(carState.angle * 180 / Math.PI).toFixed(2)}°

--- CẢM BIẾN (S1, S2, S3, S4) ---
[ ${sensors.find(s => s.id === 'S1').value},  ${sensors.find(s => s.id === 'S2').value},  ${sensors.find(s => s.id === 'S3').value},  ${sensors.find(s => s.id === 'S4').value}]

--- BỘ NÃO (LOGIC V29) ---
Map State: ${carBrainLog.mapState ?? '...'}
Trạng thái: ${carBrainLog.status || "..."}
Lỗi (Error): ${carBrainLog.error || 0}
PID: ${carBrainLog.PID || "0.00"}

--- ĐỘNG CƠ ---
Trái: ${carBrainLog.leftSpeed || "0.00"}
Phải: ${carBrainLog.rightSpeed || "0.00"}
            `;
        }

        function stopSimulationWithError(message) {
            isRunning = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            setMode('draw');
            logContent.innerHTML = `
--- TRẠNG THÁI XE ---
ĐÃ DỪNG!
Lý do: ${message}
Đã quay về chế độ Vẽ.
            `;
        }
        
        // --- VÒNG LẶP MÔ PHỎNG (GAME LOOP) ---
        function simulationLoop() {
            if (!isRunning || currentMode !== 'simulate' || !mapImageData) return;
            
            ctx.putImageData(mapImageData, 0, 0);
            
            car.readSensors();
            
            // (CẬP NHẬT V8) Đọc PID từ UI mỗi frame
            CarBrain.KP = parseFloat(pidKPInput.value) || 0.5;
            CarBrain.KI = parseFloat(pidKIInput.value) || 0.001;
            CarBrain.KD = parseFloat(pidKDInput.value) || 0.1;
            CarBrain.PID_KP_STABLE = CarBrain.KP * 0.4;
            CarBrain.PID_KP_UNSTABLE = CarBrain.KP;
            
            const decision = CarBrain.update(car.sensors); 
            if (!decision) return;
            
            const motorSpeeds = decision.motorSpeeds;
            car.update(motorSpeeds.left, motorSpeeds.right);

            if (car.x < 0 || car.x > canvas.width || car.y < 0 || car.y > canvas.height) {
                stopSimulationWithError("Xe đã đi ra khỏi đường biên.");
                return;
            }
            
            car.draw();
            updateLogPanel(car, car.sensors, decision.logData);
            
            animationFrameId = requestAnimationFrame(simulationLoop);
        }

        // --- CÁC HÀM VẼ CƠ BẢN (Grid, Clear, RedrawAll) ---
        function clearCanvas() {
            ctx.fillStyle = BACKGROUND_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function drawGrid() {
            if (!isGridVisible) return;
            ctx.save();
            ctx.strokeStyle = "#e5e7eb";
            ctx.lineWidth = 1;
            
            for (let x = GRID_SIZE; x < canvas.width; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = GRID_SIZE; y < canvas.height; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            ctx.restore();
        }
        
        function redrawAll(drawCar = true) {
            if (historyIndex > -1) {
                ctx.putImageData(history[historyIndex], 0, 0);
            } else {
                clearCanvas();
            }
            drawGrid();
            if (drawCar) {
                drawCarAtCurrentInitialPosition();
            }
        }

        // --- LỊCH SỬ (UNDO/REDO) ---
        function saveHistory() {
            history.splice(historyIndex + 1);
            history.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
            historyIndex++;
            updateUndoRedoButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                ctx.putImageData(history[historyIndex], 0, 0);
                drawGrid();
                drawCarAtCurrentInitialPosition();
                updateUndoRedoButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                ctx.putImageData(history[historyIndex], 0, 0);
                drawGrid();
                drawCarAtCurrentInitialPosition();
                updateUndoRedoButtons();
            }
        }

        function updateUndoRedoButtons() {
            undoButton.disabled = (historyIndex <= 0);
            redoButton.disabled = (historyIndex >= history.length - 1);
        }
        
        function resetHistory() {
            history = [];
            historyIndex = -1;
            clearCanvas();
        }
        
        // --- VẼ BẢN ĐỒ MẶC ĐỊNH (V7) ---
        function loadDefaultMap() {
            clearCanvas();
            
            setupLineStyle();
            ctx.lineWidth = 20; 
            
            // Đường thẳng dưới cùng
            ctx.beginPath();
            ctx.moveTo(50, 750);
            ctx.lineTo(1150, 750);
            ctx.stroke();
            
            // 3 đường dọc (Ngã ba 0111)
            ctx.beginPath();
            ctx.moveTo(250, 750);
            ctx.lineTo(250, 450);
            ctx.stroke();
            drawTriangleJunction(250, 750); // Ngã ba 1

            ctx.beginPath();
            ctx.moveTo(550, 750);
            ctx.lineTo(550, 450);
            ctx.stroke();
            drawTriangleJunction(550, 750); // Ngã ba 2
            
            ctx.beginPath();
            ctx.moveTo(850, 750);
            ctx.lineTo(850, 450);
            ctx.stroke();
            drawTriangleJunction(850, 750); // Ngã ba 3 (Đây là chỗ rẽ phải)
            
            // Đường ngang (chỗ rẽ phải)
            ctx.beginPath();
            ctx.moveTo(850, 450);
            ctx.lineTo(1150, 450);
            ctx.stroke();
            
            // Đường dọc (lên ngã tư)
            ctx.beginPath();
            ctx.moveTo(1150, 750);
            ctx.lineTo(1150, 150);
            ctx.stroke();
            
            // Ngã tư (chỗ rẽ trái)
            ctx.beginPath();
            ctx.moveTo(1150, 150);
            ctx.lineTo(800, 150);
            ctx.stroke();
            
            // Đường cong (sau ngã tư)
            ctx.beginPath();
            ctx.moveTo(800, 150);
            ctx.arcTo(600, 150, 600, 350, 100); 
            ctx.lineTo(600, 400); 
            ctx.stroke();
            
            // Đường tam giác (1001)
            ctx.beginPath();
            ctx.moveTo(600, 400);
            ctx.lineTo(400, 400); // Đường ngang
            ctx.stroke();
            drawTriangleJunction(500, 400, false); 
            
            // Đường ngang cuối (sau 1001)
            ctx.beginPath();
            ctx.moveTo(400, 400);
            ctx.lineTo(100, 400);
            ctx.stroke();
            
            // Cua cuối đường
            ctx.beginPath();
            ctx.moveTo(100, 400);
            ctx.arcTo(50, 400, 50, 350, 50);
            ctx.lineTo(50, 200); // Cụt (kết thúc)
            ctx.stroke();

            // Đặt lại vị trí xe
            initialCarX = 100;
            initialCarY = 750;
            initialCarAngle = -Math.PI / 2; 
            
            saveHistory(); 
            redrawAll(true);
        }
        
        function drawTriangleJunction(x, y, vertical = true) {
            ctx.save();
            ctx.beginPath();
            setupLineStyle();
            ctx.lineWidth = 10;
            if (vertical) {
                ctx.moveTo(x - 20, y - 20);
                ctx.lineTo(x, y);
                ctx.lineTo(x + 20, y - 20);
            } else { 
                ctx.moveTo(x - 20, y - 20);
                ctx.lineTo(x, y);
                ctx.lineTo(x - 20, y + 20);
            }
            ctx.stroke();
            ctx.restore();
        }
        

        // --- QUẢN LÝ CHẾ ĐỘ VÀ CÔNG CỤ ---
        function resetDrawState() {
            drawState.clickCount = 0;
            drawState.p1 = null;
            drawState.p2 = null;
            previewMapData = null; 
            isDrawing = false; 
            lineStartPoint = null;
        }

        function setDrawTool(tool) {
            currentDrawTool = tool;
            resetDrawState();
            
            toolFreehand.disabled = (tool === 'freehand');
            toolLine.disabled = (tool === 'line');
            toolArc.disabled = (tool === 'arc');
            toolTriangle.disabled = (tool === 'triangle');
            toolRect.disabled = (tool === 'rect');
            toolEraser.disabled = (tool === 'eraser');
            
            canvas.classList.remove('draw-mode-freehand', 'draw-mode-line', 'draw-mode-rect', 'draw-mode-eraser');
            if (tool === 'freehand') canvas.classList.add('draw-mode-freehand');
            else if (tool === 'eraser') canvas.classList.add('draw-mode-eraser');
            else if (tool === 'rect') canvas.classList.add('draw-mode-rect');
            else canvas.classList.add('draw-mode-line'); 
        }
        
        function setMode(mode) {
            currentMode = mode;
            isRunning = false; 
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            canvas.classList.remove('draw-mode-freehand', 'draw-mode-line', 'draw-mode-rect', 'draw-mode-eraser', 'place-car-mode', 'simulate-mode');
            
            drawButton.disabled = false;
            placeCarButton.disabled = false;
            simulateButton.disabled = false;
            stopButton.disabled = true;
            clearMapButton.disabled = false;
            resetCarButton.disabled = false;
            saveMapButton.disabled = false;
            loadMapButton.disabled = false;
            loadDefaultMapButton.disabled = false;
            simulationOptions.style.display = 'none'; 
            
            if (mode === 'draw') {
                drawingTools.style.display = 'flex'; 
                drawButton.disabled = true;
                
                if (mapImageData) { 
                     ctx.putImageData(mapImageData, 0, 0);
                     mapImageData = null; 
                } 
                
                redrawAll(true);
                setDrawTool(currentDrawTool); 
                updateUndoRedoButtons(); 
            } else if (mode === 'place_car') {
                drawingTools.style.display = 'none'; 
                canvas.classList.add('place-car-mode');
                placeCarButton.disabled = true;
                redrawAll(true);
                ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                ctx.font = "16px Inter";
                ctx.textAlign = "center";
                ctx.fillText("Click và Kéo để đặt vị trí và hướng xe. Thả chuột để hoàn tất.", canvas.width / 2, 30);
            } else if (mode === 'simulate') {
                drawingTools.style.display = 'none'; 
                simulationOptions.style.display = 'flex'; 
                canvas.classList.add('simulate-mode');
                simulateButton.disabled = true;
                stopButton.disabled = false;
                drawButton.disabled = false;
                placeCarButton.disabled = true;
                clearMapButton.disabled = true; 
                saveMapButton.disabled = true;
                loadMapButton.disabled = true;
                loadDefaultMapButton.disabled = true;

                redrawAll(false);
                mapImageData = ctx.getImageData(0, 0, canvas.width, canvas.height); 
                
                car.reset();
                CarBrain.reset(); 
                isRunning = true;
                simulationLoop();
            }
        }
        
        function drawCarAtCurrentInitialPosition() {
            const tempX = car.x;
            const tempY = car.y;
            const tempAngle = car.angle;
            
            car.x = initialCarX;
            car.y = initialCarY;
            car.angle = initialCarAngle;
            car.readSensors(); 
            car.draw();
            
            car.x = tempX;
            car.y = tempY;
            car.angle = tempAngle;
        }

        // --- GÁN SỰ KIỆN CHO CÁC NÚT ---
        drawButton.addEventListener('click', () => setMode('draw'));
        placeCarButton.addEventListener('click', () => setMode('place_car'));
        simulateButton.addEventListener('click', () => setMode('simulate'));
        stopButton.addEventListener('click', () => setMode('draw')); 

        resetCarButton.addEventListener('click', () => {
            isRunning = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            CarBrain.reset();
            redrawAll(true);

            if (currentMode === 'simulate') {
                redrawAll(false);
                mapImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                car.reset(); 
                isRunning = true;
                simulationLoop();
            }
        });

        clearMapButton.addEventListener('click', () => {
            if (currentMode !== 'simulate') { 
                if (confirm('Bạn có chắc muốn xóa toàn bộ bản đồ (để vẽ map mới)?')) {
                    mapImageData = null;
                    initialCarX = 100;
                    initialCarY = 750; 
                    initialCarAngle = -Math.PI / 2;
                    resetHistory(); 
                    saveHistory(); 
                    redrawAll(true);
                }
            }
        });
        
        loadDefaultMapButton.addEventListener('click', () => {
            if (currentMode !== 'simulate') {
                if (confirm('Tải lại bản đồ V29 sẽ xóa bản đồ hiện tại của bạn. Bạn có chắc?')) {
                    resetHistory();
                    loadDefaultMap();
                }
            }
        });

        toolFreehand.addEventListener('click', () => setDrawTool('freehand'));
        toolLine.addEventListener('click', () => setDrawTool('line'));
        toolArc.addEventListener('click', () => setDrawTool('arc'));
        toolTriangle.addEventListener('click', () => setDrawTool('triangle'));
        toolRect.addEventListener('click', () => setDrawTool('rect'));
        toolEraser.addEventListener('click', () => setDrawTool('eraser'));
        
        toggleGridButton.addEventListener('click', () => {
            isGridVisible = !isGridVisible;
            toggleGridButton.textContent = isGridVisible ? "Ẩn Lưới" : "Hiện Lưới";
            toggleGridButton.classList.toggle('bg-blue-200', isGridVisible);
            redrawAll(true);
        });
        lineWidthSlider.addEventListener('input', (e) => {
            const width = parseInt(e.target.value, 10);
            LINE_WIDTH = width;
            ERASER_WIDTH = width + 2;
        });
        
        carSpeedSlider.addEventListener('input', (e) => {
            const speed = parseFloat(e.target.value);
            car.speed = speed;
            carSpeedValue.textContent = speed.toFixed(1);
        });

        undoButton.addEventListener('click', undo);
        redoButton.addEventListener('click', redo);
        
        saveMapButton.addEventListener('click', () => {
            if (currentMode === 'simulate') return;
            try {
                const mapData = history[historyIndex];
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                tempCanvas.getContext('2d').putImageData(mapData, 0, 0);
                
                const dataUrl = tempCanvas.toDataURL();
                
                navigator.clipboard.writeText(dataUrl).then(() => {
                    alert("Đã sao chép dữ liệu bản đồ vào clipboard!");
                }, () => {
                    alert("Không thể sao chép tự động. Vui lòng thử lại.");
                });
            } catch (e) {
                alert("Lỗi khi lưu bản đồ: " + e.message);
            }
        });

        loadMapButton.addEventListener('click', () => {
            if (currentMode === 'simulate') return;
            const dataUrl = prompt("Dán (Paste) chuỗi dữ liệu bản đồ (Base64) vào đây:");
            if (dataUrl) {
                const img = new Image();
                img.onload = function() {
                    clearCanvas();
                    ctx.drawImage(img, 0, 0);
                    saveHistory();
                    redrawAll(true);
                };
                img.onerror = function() {
                    alert("Dữ liệu bản đồ không hợp lệ.");
                };
                img.src = dataUrl;
            }
        });


        // --- GÁN SỰ KIỆN VẼ BẰNG CHUỘT ---
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }
        
        function setupLineStyle() {
            ctx.strokeStyle = LINE_COLOR;
            ctx.lineWidth = LINE_WIDTH;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
        }
        
        function setupEraserStyle() {
            ctx.strokeStyle = BACKGROUND_COLOR;
            ctx.lineWidth = ERASER_WIDTH;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
        }

        function drawArc(p1, p2, p3) {
            setupLineStyle();
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.quadraticCurveTo(p2.x, p2.y, p3.x, p3.y);
            ctx.stroke();
        }
        function drawTriangle(p1, p2, p3) {
            setupLineStyle();
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.closePath(); 
            ctx.stroke();
        }
        function drawRect(p1, p2) {
            setupLineStyle();
            ctx.strokeRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
        }

        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);
            
            if (currentMode === 'draw') {
                if (currentDrawTool === 'freehand' || currentDrawTool === 'eraser') {
                    isDrawing = true;
                    (currentDrawTool === 'eraser' ? setupEraserStyle() : setupLineStyle());
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                    previewMapData = ctx.getImageData(0, 0, canvas.width, canvas.height); 
                } else if (currentDrawTool === 'line' || currentDrawTool === 'rect') {
                    isDrawing = true;
                    lineStartPoint = pos;
                    previewMapData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                } else if (currentDrawTool === 'arc') {
                    drawState.clickCount++;
                    if (drawState.clickCount === 1) { 
                        drawState.p1 = pos;
                        previewMapData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    } else if (drawState.clickCount === 2) { 
                        drawState.p2 = pos;
                    } else if (drawState.clickCount === 3) { 
                        ctx.putImageData(previewMapData, 0, 0); 
                        drawGrid();
                        drawArc(drawState.p1, drawState.p2, pos); 
                        resetDrawState();
                        saveHistory(); 
                    }
                } else if (currentDrawTool === 'triangle') {
                    drawState.clickCount++;
                    if (drawState.clickCount === 1) { 
                        drawState.p1 = pos;
                        previewMapData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    } else if (drawState.clickCount === 2) { 
                        drawState.p2 = pos;
                    } else if (drawState.clickCount === 3) { 
                        ctx.putImageData(previewMapData, 0, 0); 
                        drawGrid();
                        drawTriangle(drawState.p1, drawState.p2, pos); 
                        resetDrawState();
                        saveHistory(); 
                    }
                }
            } else if (currentMode === 'place_car') {
                isDrawing = true; 
                initialCarX = pos.x;
                initialCarY = pos.y;
                previewMapData = ctx.getImageData(0, 0, canvas.width, canvas.height); 
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);

            if (currentMode === 'place_car' && isDrawing) {
                initialCarAngle = Math.atan2(pos.y - initialCarY, pos.x - initialCarX);
                
                ctx.putImageData(previewMapData, 0, 0);
                drawGrid();
                
                ctx.beginPath();
                ctx.moveTo(initialCarX, initialCarY);
                ctx.lineTo(pos.x, pos.y);
                ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                drawCarAtCurrentInitialPosition(); 
                return;
            }

            if (currentMode !== 'draw') return;
            if (!isDrawing && drawState.clickCount === 0) return; 

            if (isDrawing && (currentDrawTool === 'freehand' || currentDrawTool === 'eraser')) {
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
            } else if (isDrawing && currentDrawTool === 'line') {
                ctx.putImageData(previewMapData, 0, 0);
                drawGrid();
                setupLineStyle();
                ctx.beginPath();
                ctx.moveTo(lineStartPoint.x, lineStartPoint.y);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
            } else if (isDrawing && currentDrawTool === 'rect') {
                ctx.putImageData(previewMapData, 0, 0);
                drawGrid();
                drawRect(lineStartPoint, pos);
            } else if (currentDrawTool === 'arc') {
                if (drawState.clickCount === 1) { 
                    ctx.putImageData(previewMapData, 0, 0);
                    drawGrid();
                    setupLineStyle();
                    ctx.beginPath();
                    ctx.moveTo(drawState.p1.x, drawState.p1.y);
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                } else if (drawState.clickCount === 2) { 
                    ctx.putImageData(previewMapData, 0, 0);
                    drawGrid();
                    drawArc(drawState.p1, drawState.p2, pos); 
                }
            } else if (currentDrawTool === 'triangle') {
                if (drawState.clickCount === 1) { 
                    ctx.putImageData(previewMapData, 0, 0);
                    drawGrid();
                    setupLineStyle();
                    ctx.beginPath();
                    ctx.moveTo(drawState.p1.x, drawState.p1.y);
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                } else if (drawState.clickCount === 2) { 
                    ctx.putImageData(previewMapData, 0, 0);
                    drawGrid();
                    drawTriangle(drawState.p1, drawState.p2, pos); 
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            const pos = getMousePos(e);
            
            if (currentMode === 'place_car') {
                if (isDrawing) {
                    isDrawing = false;
                    initialCarAngle = Math.atan2(pos.y - initialCarY, pos.x - initialCarX);
                    
                    ctx.putImageData(previewMapData, 0, 0);
                    drawGrid();
                    drawCarAtCurrentInitialPosition(); 
                    previewMapData = null;
                }
                return;
            }

            if (currentMode !== 'draw' || !isDrawing) return;

            if (currentDrawTool === 'freehand' || currentDrawTool === 'eraser') {
                isDrawing = false;
                ctx.beginPath(); 
                saveHistory(); 
            } else if (currentDrawTool === 'line') {
                isDrawing = false;
                ctx.putImageData(previewMapData, 0, 0); 
                drawGrid();
                setupLineStyle();
                ctx.beginPath();
                ctx.moveTo(lineStartPoint.x, lineStartPoint.y);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke(); 
                
                resetDrawState();
                saveHistory(); 
            } else if (currentDrawTool === 'rect') {
                isDrawing = false;
                ctx.putImageData(previewMapData, 0, 0); 
                drawGrid();
                drawRect(lineStartPoint, pos);
                
                resetDrawState();
                saveHistory(); 
            }
        });
        
        canvas.addEventListener('mouseleave', () => {
            if (currentMode === 'place_car' && isDrawing) {
                isDrawing = false;
                if (previewMapData) {
                    ctx.putImageData(previewMapData, 0, 0); 
                    drawGrid();
                }
                drawCarAtCurrentInitialPosition(); 
                previewMapData = null;
            }

            if (currentMode !== 'draw') return;
            
            if (isDrawing) {
                isDrawing = false;
                if (previewMapData) {
                    ctx.putImageData(previewMapData, 0, 0);
                    drawGrid();
                }
                resetDrawState();
            }
        });

        // --- KHỞI TẠO ---
        car.speed = parseFloat(carSpeedSlider.value);
        LINE_WIDTH = parseInt(lineWidthSlider.value, 10);
        ERASER_WIDTH = LINE_WIDTH + 2;
        
        setMode('draw'); 
        setDrawTool('freehand'); 
        
        resetHistory();
        loadDefaultMap(); // TẢI BẢN ĐỒ V29 MẶC ĐỊNH

    </script>
</body>
</html>

